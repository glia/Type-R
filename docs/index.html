<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Type-R 2.1 API Reference</title>

    <link rel="icon" href="images/logo-dark.png" />
    <link href="lib/stylesheets/screen.css" rel="stylesheet" type="text/css" media="screen" />
    <link href="lib/stylesheets/print.css" rel="stylesheet" type="text/css" media="print" />
    <link href="lib/stylesheets/default.css" rel="stylesheet" type="text/css" />

    <style>
      .logo-section img {
        vertical-align: middle;
        margin: 15px;
        height: 48px;
      }

      .logo-section .logo-text {
        vertical-align: middle;
        color: white;
        display: inline-block;
      }

      .logo-section .logo-caption {
        font-size: 28px;
      }

    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
      <script src="lib/javascripts/all.js" type="text/javascript"></script>

      <script>
        $(function() {
          var langs = [];
          setupLanguages( langs );
        });
      </script>
  </head>

  <body class="index">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <div class="logo-section">
        <img src="images/logo.png" />
        <div class="logo-text">
          <div class="logo-caption">Type-R 2.1</div>
          <div>universal state management</div>
        </div>
        
      </div>
        <div class="lang-selector">
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
                <li><a href="https://github.com/Volicon/Type-R">GitHub repository</a></li>
                <li><a href="https://github.com/Volicon/Type-R/issues">Report the bug</a></li>
                <li><a href="https://groups.google.com/forum/#!forum/volicon-open-source">Ask the question</a></li>
                <li><a href="http://www.volicon.com/">Supported by <img style="vertical-align: middle" src="images/volicon_verizon_dm.png"/></a></li>
        </ul>
    </div>
    <div class="page-wrapper">
        <div class="content">
          <h1 id="getting-started">Getting started</h1>
<p>Type-R is the modern JS state framework supporting observable changes, state validation, JSON serialization and promised I/O. It&#39;s designed to meet the requirements of the complex JS data layer on both front-end and back-end.</p>
<p>Features:</p>
<ul>
<li><em>Deeply observable changes</em><ul>
<li>The series of updates can be grouped to transactions emitting the single change event.</li>
<li>There are fine-grained change events allowing the cascade of reactions executed as a single transaction.</li>
</ul>
</li>
<li><em>Serialization and persistence</em><ul>
<li>Type-R data structures are serializable to JSON by default.</li>
<li>Support for both nested JSON and relationship by id.</li>
<li>JSON mapping can be customized for every particular attribute or class.</li>
<li>I/O endpoints abstract out the persistence protocol.</li>
</ul>
</li>
<li><em>Lazily evaluated validation</em><ul>
<li>The validation is performed on the first access to the validation error field.</li>
<li>Validation results are cached and never computed twice for unchanged data.</li>
</ul>
</li>
<li><em>Dynamic type safety</em><ul>
<li>Types are asserted every </li>
<li>The shape of both data structures and generated JSON is guaranteed to match the definitions.</li>
</ul>
</li>
<li><em>Performance</em><ul>
<li>Type-R data structures are designed to handle large collections (10K elements and more) with sub-second delays.</li>
<li>Updates are about 10 times more efficient than BackboneJS models and collections.</li>
</ul>
</li>
</ul>
<p><img src="images/overview.png" alt="overview"></p>
<p>Type-R is completely unopinionated on the client-server transport protocol and the view layer technology. It&#39;s your perfect M and VM in modern MVVM or MVC architecture.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { define, Record } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

<span class="hljs-comment">// Define email attribute type with encapsulated validation check.</span>
<span class="hljs-keyword">const</span> Email = <span class="hljs-built_in">String</span>.has.check( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x! || x.indexOf( <span class="hljs-string">'@'</span> ) &gt;= <span class="hljs-number">0</span>, <span class="hljs-string">'Invalid email'</span> );

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span>  : <span class="hljs-built_in">String</span>.isRequired, <span class="hljs-comment">// should not be empty for the record to be valid.</span>
        email : Email.isRequired
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">created</span> : <span class="hljs-built_in">Date</span> <span class="hljs-comment">//  = new Date()</span>
        author  : User, <span class="hljs-comment">// aggregated User record.</span>
        to      : User.Collection, <span class="hljs-comment">// aggregating collection of users</span>
        subject : <span class="hljs-string">''</span>,
        <span class="hljs-attr">body</span>    : <span class="hljs-string">''</span>
    }
}

<span class="hljs-keyword">const</span> msg = <span class="hljs-keyword">new</span> Message();
assert( !msg.isValid() ); <span class="hljs-comment">// Is not valid because msg.author has empty attributes</span>

<span class="hljs-comment">// Listen for the changes in aggregation tree...</span>
msg.on( <span class="hljs-string">'change'</span>, () =&gt; <span class="hljs-built_in">console</span>.log( <span class="hljs-string">'change!!!'</span> ) );

msg.transaction( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">// Prepare to make the sequence of changes on msg</span>
    msg.author.name = <span class="hljs-string">'John Dee'</span>; <span class="hljs-comment">// No 'change' event yet as we're in the transaction. </span>
    msg.author.email = <span class="hljs-string">'dee@void.com'</span>; 

    assert( msg.isValid() ); <span class="hljs-comment">// Now msg is valid as all of its attributes are valid.</span>
}); <span class="hljs-comment">// Got single 'change!!!' message in the console.</span>
</code></pre>
<h2 id="installation-and-requirements">Installation and requirements</h2>
<p>Is packed as UMD and ES6 module. No peer dependencies are required.</p>
<p><code>npm install type-r --save-dev</code></p>
<aside class="success">IE10+, Edge, Safari, Chrome, and Firefox are supported</aside>

<aside class="warning">IE9 and Opera may work but has not been tested. IE8 won't work.</aside>

<h2 id="how-the-type-r-compares-with-x-">How the Type-R compares with X?</h2>
<p>Type-R started to develop in 2014 as the modern substitution for BackboneJS, which would retain the spirit of the BackboneJS simplicity but would be an order of magnitude faster and superior to Ember Data in its capabilities to describe complex data.</p>
<p>The closest things to the Type-R are <a href="https://guides.emberjs.com/v2.2.0/models/">Ember Data</a>, <a href="http://backbonejs.org/#Model">BackboneJS models and collections</a>, and <a href="https://github.com/mobxjs/mobx">mobx</a>.</p>
<p>There are both similarities and differences:</p>
<ul>
<li>In contrast to mobx, Type-R detects <em>deeply nested changes</em>.</li>
<li>Records and Collections resembles Backbone&#39;s Models/Collections, but Record is <em>not an object hash</em> but class and it&#39;s updates are ~10 times faster.</li>
<li>Data validation is comparable to one in Ember Data, but it&#39;s lazily evaluated and cached.</li>
<li>id-relationship resembles one in <a href="https://guides.emberjs.com/v2.2.0/models/relationships/">Ember Data</a>, which was used a source of inspiration. But Type-R supports the first-class aggregation as well.</li>
<li>Like Ember Data, Type-R supports abstract data adapters (I/O endpoints).</li>
<li>Unlike Ember and Backbone, Type-R is unopinionated on the view layer and routing. Like in mobx, there are React bindings.</li>
</ul>
<p>Speaking of the distinguishing differences,</p>
<ul>
<li>Type-R encourages using of the <em>layered application state</em> instead of the global singleton store. In Type-R, the stores are the special kind of records which can participate in dynamically configured lookup chains. There might be as many dynamically created and disposed stores as you need, starting with no stores at all.</li>
<li>Type-R&#39;s records are protected from improper assignment with run-time type assertions and conversions.</li>
<li>Type-R distinguishes aggregation and the plain association operating with <em>aggregation trees</em> formed by nested records and collections. Aggregation tree is serialized as nested JSON. Operations like <code>clone()</code>, <code>dispose()</code>, <code>isValid()</code> and <code>toJSON()</code> are performed recursively on elements of aggregation tree gracefully handling the references to shared objects.</li>
</ul>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Type-R</th>
<th>Backbone Models</th>
<th>Ember Data</th>
<th>mobx</th>
</tr>
</thead>
<tbody>
<tr>
<td>Observable changes in object graph</td>
<td>✓</td>
<td>-</td>
<td>-</td>
<td>✓</td>
</tr>
<tr>
<td>JSON Serialization</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>Validation</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>Dynamic Type Safety</td>
<td>✓</td>
<td>-</td>
<td>for serialization only</td>
<td>-</td>
</tr>
<tr>
<td>Aggregation</td>
<td>✓</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Relations by id</td>
<td>✓</td>
<td>-</td>
<td>✓</td>
<td>- </td>
</tr>
<tr>
<td>Generalized I/O</td>
<td>✓</td>
<td>sync function</td>
<td>✓</td>
<td>- </td>
</tr>
</tbody>
</table>

<h1 id="record">Record</h1>
<p>Record is the serializable class with typed attributes, observable changes, and custom validation checks. It is the main building block for managing the application state; component local state, stores, and collection elements are all subclasses of the <code>Record</code>.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { define, Record } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

<span class="hljs-comment">// ⤹ required to make magic work  </span>
@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-comment">// ⤹ attribute's declaration</span>
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">firstName</span> : <span class="hljs-string">''</span>, <span class="hljs-comment">// ⟵ String type is inferred from the default value</span>
        lastName  : <span class="hljs-built_in">String</span>, <span class="hljs-comment">// ⟵ Or you can just mention its constructor</span>
        email     : <span class="hljs-built_in">String</span>.value( <span class="hljs-literal">null</span> ), <span class="hljs-comment">//⟵ Or you can provide both</span>
        createdAt : <span class="hljs-built_in">Date</span>, <span class="hljs-comment">// ⟵ And it works for any constructor.</span>
        <span class="hljs-comment">// And you can attach ⤹ metadata to fine-tune attribute's behavior</span>
        lastLogin : <span class="hljs-built_in">Date</span>.value( <span class="hljs-literal">null</span> ).has.toJSON( <span class="hljs-literal">false</span> ) <span class="hljs-comment">// ⟵ not serializable</span>
    }
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User();
<span class="hljs-built_in">console</span>.log( user.createdAt ); <span class="hljs-comment">// ⟵ this is an instance of Date created for you.</span>

<span class="hljs-keyword">const</span> users = <span class="hljs-keyword">new</span> User.Collection(); <span class="hljs-comment">// ⟵ Collections are defined automatically.</span>
users.on( <span class="hljs-string">'changes'</span>, () =&gt; updateUI( users ) ); <span class="hljs-comment">// ⟵ listen to the changes.</span>

users.set( json, { <span class="hljs-attr">parse</span> : <span class="hljs-literal">true</span> } ); <span class="hljs-comment">// ⟵ parse raw JSON from the server.</span>
users.updateEach( <span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.firstName = <span class="hljs-string">''</span> ); <span class="hljs-comment">// ⟵ bulk update triggering 'changes' once</span>
</code></pre>
<h2 id="definition">Definition</h2>
<p>Record is defined as a regular ES6 class, except:</p>
<ul>
<li>it <em>must</em> extend the <code>Record</code> base class;</li>
<li>it <em>must</em> be preceded with the <code>@define</code> decorator;</li>
<li>it <em>should</em> use <code>static attributes</code> to declare attributes.</li>
</ul>
<p>Attributes declaration is an object with attribute names mapped to their type annotation and/or default value.
Once defined, attributes can be accessed as regular class members.</p>
<p>The minimal record definition looks like this:</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRecord</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-string">''</span>
    }
}
</code></pre>
<aside class="warning">
Unlike in the majority of the JS state management framework, Record is <b>not the key-value hash</b>. It needs to be explicitly defined for every data structure of different shape, in a similar way as it's done in statically typed languages.
</aside>

<h3 id="decorator-define"><code>decorator</code> @define</h3>
<p><em>Must</em> be placed before the class definition.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { define, Record } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    ...    
}
</code></pre>
<h3 id="static-attributes-name-attrdef-"><code>static</code> attributes = { name : <code>attrDef</code>, ... }</h3>
<p>Record&#39;s attributes definition. Lists attribute names along with their types, default values, and metadata controlling different aspects of attribute behavior.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span>    : <span class="hljs-built_in">String</span>.value( <span class="hljs-string">'John Dow'</span> ),
        <span class="hljs-attr">email</span>   : <span class="hljs-string">'john.dow@mail.com'</span>, <span class="hljs-comment">// Same as String.value( 'john.dow@mail.com' )</span>
        address : <span class="hljs-built_in">String</span>, <span class="hljs-comment">// Same as String.value( '' )</span>
    }
}
</code></pre>
<p>The Record guarantee that <em>every attribute will retain the value of the declared type</em>. Whenever an attribute is being assigned with the value which is not compatible with its declared type, the type is being converted with an invocation of the constructor: <code>new Type( value )</code> (primitive types are treated specially).</p>
<h3 id="static-idattribute-attrname-"><code>static</code> idAttribute = &#39;attrName&#39;</h3>
<p>A record&#39;s unique identifier is stored under the pre-defined <code>id</code> attribute.
If you&#39;re directly communicating with a backend (CouchDB, MongoDB) that uses a different unique key, you may set a Record&#39;s <code>idAttribute</code> to transparently map from that key to id.</p>
<p>Record&#39;s <code>id</code> property will still be linked to Record&#39;s id, no matter which value <code>idAttribute</code> has.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
  <span class="hljs-keyword">static</span> idAttribute =  <span class="hljs-string">"_id"</span>;
  <span class="hljs-keyword">static</span> attributes = {
      <span class="hljs-attr">_id</span> : <span class="hljs-built_in">Number</span>,
      <span class="hljs-attr">name</span> : <span class="hljs-string">''</span>
  }
}

<span class="hljs-keyword">const</span> cake = <span class="hljs-keyword">new</span> Meal({ <span class="hljs-attr">_id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Cake"</span> });
alert(<span class="hljs-string">"Cake id: "</span> + cake.id);
</code></pre>
<h3 id="attrdef-type"><code>attrDef</code> : Type</h3>
<p>When the function is used as <code>attrDef</code>, it&#39;s treated as the constructor function. Any constructor function which behaves as <em>converting constructor</em> (like <code>new Date( msecs )</code>) may be used as an attribute type.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span> <span class="hljs-comment">// String attribute which is "" by default.</span>
        createdAt : <span class="hljs-built_in">Date</span> <span class="hljs-comment">// Date attribute</span>
        ...
    }
}
</code></pre>
<h3 id="attrdef-defaultvalue"><code>attrDef</code> : defaultValue</h3>
<p>When value of other type than function is used as <code>attrDef</code> it&#39;s treated as attribute&#39;s default value. Attribute&#39;s type is being inferred from the value.</p>
<p>Use the general form of attribute definition for attributes of <code>Function</code> type: <code>Function.value( theFunction )</code>.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GridColumn</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-string">''</span>, <span class="hljs-comment">// String attribute which is '' by default.</span>
        render : <span class="hljs-built_in">Function</span>.value( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ),
        ...
    }
}
</code></pre>
<h3 id="attrdef-type-value-defaultvalue-"><code>attrDef</code> : Type.value( defaultValue )</h3>
<p>The general form of attribute definition is <code>Type.value( defaultValue )</code>, where the <code>Type</code> is the corresponding constructor function.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">phone</span> : <span class="hljs-built_in">String</span>.value( <span class="hljs-literal">null</span> ) <span class="hljs-comment">// String attribute which is null by default.</span>
        ...
    }
}
</code></pre>
<p>The record is <em>recursive</em> if it&#39;s uses the type of itself in its attribute definition.</p>
<h3 id="attrdef-date"><code>attrDef</code> : Date</h3>
<p>Date attribute initialized as <code>new Date()</code>. Represented in JSON as string or number depending on the type:</p>
<ul>
<li><code>Date</code> - as ISO date string.</li>
<li><code>Date.microsoft</code> - as Microsoft&#39;s <code>&quot;/Date(msecs)/&quot;</code> string.</li>
<li><code>Date.timestamp</code> - as UNIX integer timestamp.</li>
</ul>
<h3 id="static-collection"><code>static</code> Collection</h3>
<p>The default record&#39;s collection class automatically defined for every Record subclass. Can be referenced as <code>Record.Collection</code>.</p>
<p>May be explicitly assigned in record&#39;s definition with custom collection class.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Declare the collection class.</span>
@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comments</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span>.<span class="hljs-title">Collection</span> </span>{}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span></span>{
    <span class="hljs-keyword">static</span> Collection = Comments; <span class="hljs-comment">// Make it the default Comment collection.</span>

    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">text</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">replies</span> : Comments
    }
}
</code></pre>
<h3 id="attrdef-type-has-and-type-type-"><code>attrDef</code> Type.has and type( Type )</h3>
<p>Attribute definition can have different metadata attached which affects various aspects of attribute&#39;s behavior. Metadata is attached with
a chain of calls after the <code>Ctor.has</code> property or <code>type( Ctor )</code> call. Attribute&#39;s default value is the most common example of such a metadata and is the single option which can be applied to the constructor function directly.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { define, type, Record }

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dummy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">a</span> : <span class="hljs-built_in">String</span>.has.value( <span class="hljs-string">"a"</span> ), <span class="hljs-comment">// Same as String.value( "a" )</span>
        b : type( <span class="hljs-built_in">String</span> ).value( <span class="hljs-string">"a"</span> ) <span class="hljs-comment">// Same as above</span>
    }
}
</code></pre>
<h2 id="definitions-in-typescript">Definitions in TypeScript</h2>
<p>Type-R implements experimental support for TypeScript record definitions.</p>
<h3 id="decorator-attr"><code>decorator</code> @attr</h3>
<p>The simplest form of attribute definition. Requires <code>reflect-metadata</code> npm package and <code>emitDecoratorMetadata</code> option set to true in the <code>tsconfig.json</code>.</p>
<p>No metadata can be attached.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { define, attr, Record } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    @attr name : string
    @attr email : string
}
</code></pre>
<h3 id="decorator-attr-attrdef-"><code>decorator</code> @attr( attrDef )</h3>
<p>Long form of the attribute definition. Accepts arbitraty Type-R attribute definition as a parameter. Could be used if metadata must be attached to an attributed.
Doesn&#39;t require <code>reflect-metadata</code> package.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { define, attr, Record } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    @attr( <span class="hljs-built_in">String</span>.value( <span class="hljs-number">5</span> ) ) name : string
    @attr( <span class="hljs-string">"5"</span> ) name : string <span class="hljs-comment">// String type is infered from the default value.</span>
    @attr( <span class="hljs-built_in">String</span>.has.toJSON( <span class="hljs-literal">false</span> ) ) email : string
}
</code></pre>
<h3 id="decorator-type-ctor-as"><code>decorator</code> @type( Ctor ).as</h3>
<p>Attribute definition has <code>.as</code> property which converts the definition to the attribute&#39;s decorator. Can be used in conjunction with <code>type()</code> function to provide an 
alternative syntax for attribute definitions.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { define, type, Record } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    @type( <span class="hljs-built_in">String</span> ).value( <span class="hljs-number">5</span> ).as name : string
    @type( <span class="hljs-built_in">String</span> ).toJSON( <span class="hljs-literal">false</span> ).as email : string
}
</code></pre>
<h2 id="create-and-dispose">Create and dispose</h2>
<p>Record behaves as regular ES6 class with attributes accessible as properties.</p>
<h3 id="new-record-">new Record()</h3>
<p>Create an instance of the record with default attribute values taken from the attributes definition.</p>
<p>When no default value is explicitly provided for an attribute, it&#39;s initialized as <code>new Type()</code> (just <code>Type()</code> for primitives). When the default value is provided and it&#39;s not compatible with the attribute type, it&#39;s converted with <code>new Type( defaultValue )</code> call.</p>
<h3 id="new-record-attrname-value-options-">new Record({ attrName : value, ... }, options? )</h3>
<p>When creating an instance of a record, you can pass in the initial attribute values to override the defaults.</p>
<p>If <code>{parse: true}</code> option is used, <code>attrs</code> is assumed to be the JSON.</p>
<p>If the value of the particular attribute is not compatible with its type, it&#39;s converted to the declared type invoking the constructor <code>new Type( value )</code> (just <code>Type( value )</code> for primitives).</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">title</span>  : <span class="hljs-string">''</span>,
        <span class="hljs-attr">author</span> : <span class="hljs-string">''</span>
    }
}

<span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> Book({
  <span class="hljs-attr">title</span>: <span class="hljs-string">"One Thousand and One Nights"</span>,
  <span class="hljs-attr">author</span>: <span class="hljs-string">"Scheherazade"</span>
});
</code></pre>
<h3 id="record-clone-">record.clone()</h3>
<p>Create the deep copy of the aggregation tree, recursively cloning all aggregated records and collections. References to shared members will be copied, but not shared members themselves.</p>
<h3 id="callback-record-initialize-attrs-options-"><code>callback</code> record.initialize( attrs?, options? )</h3>
<p>Called at the end of the <code>Record</code> constructor when all attributes are assigned and the record&#39;s inner state is properly initialized. Takes the same arguments as
a constructor.</p>
<h3 id="record-dispose-">record.dispose()</h3>
<p>Recursively dispose the record and its aggregated members. &quot;Dispose&quot; means that elements of the aggregation tree will unsubscribe from all event sources. It&#39;s crucial to prevent memory leaks in SPA.</p>
<p>The whole aggregation tree will be recursively disposed, shared members won&#39;t.</p>
<h2 id="read-and-update">Read and Update</h2>
<h3 id="record-cid">record.cid</h3>
<p>Read-only client-side record&#39;s identifier. Generated upon creation of the record and is unique for every record&#39;s instance. Cloned records will have different <code>cid</code>.</p>
<h3 id="record-id">record.id</h3>
<p>Predefined record&#39;s attribute, the <code>id</code> is an arbitrary string (integer id or UUID). <code>id</code> is typically generated by the server. It is used in JSON for id-references.</p>
<p>Records can be retrieved by <code>id</code> from collections, and there can be just one instance of the record with the same <code>id</code> in the particular collection.</p>
<h3 id="record-isnew-">record.isNew()</h3>
<p>Has this record been saved to the server yet? If the record does not yet have an <code>id</code>, it is considered to be new.</p>
<h3 id="record-attrname">record.attrName</h3>
<p>Record&#39;s attributes may be directly accessed as <code>record.name</code>.</p>
<aside class="warning">Please note, that you *have to declare all attributes* in `static attributes` declaration.</aside>

<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">balance</span> : <span class="hljs-built_in">Number</span>
    }
}

<span class="hljs-keyword">const</span> myAccount = <span class="hljs-keyword">new</span> Account({ <span class="hljs-attr">name</span> : <span class="hljs-string">'mine'</span> });
myAccount.balance += <span class="hljs-number">1000000</span>; <span class="hljs-comment">// That works. Good, eh?</span>
</code></pre>
<h3 id="record-attrname-value">record.attrName = value</h3>
<p>Assign the record&#39;s attribute. If the value is not compatible with attribute&#39;s type from the declaration, it is converted:</p>
<ul>
<li>with <code>Type( value )</code> call, for primitive types;</li>
<li>with <code>record.attrName.set( value )</code>, for existing record or collection (updated in place);</li>
<li>with <code>new Type( value )</code> in all other cases.</li>
</ul>
<p>Record triggers events on changes:</p>
<ul>
<li><code>change:attrName</code> <em>( record, value )</em>.</li>
<li><code>change</code> <em>( record )</em>.</li>
</ul>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">title</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">author</span> : <span class="hljs-built_in">String</span>
        price : <span class="hljs-built_in">Number</span>,
        <span class="hljs-attr">publishedAt</span> : <span class="hljs-built_in">Date</span>,
        <span class="hljs-attr">available</span> : <span class="hljs-built_in">Boolean</span>
    }
}

<span class="hljs-keyword">const</span> myBook = <span class="hljs-keyword">new</span> Book({ <span class="hljs-attr">title</span> : <span class="hljs-string">"State management with Type-R"</span> });
myBook.author = <span class="hljs-string">'Vlad'</span>; <span class="hljs-comment">// That works.</span>
myBook.price = <span class="hljs-string">'Too much'</span>; <span class="hljs-comment">// Converted with Number( 'Too much' ), resulting in NaN.</span>
myBook.price = <span class="hljs-string">'123'</span>; <span class="hljs-comment">// = Number( '123' ).</span>
myBook.publishedAt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); <span class="hljs-comment">// Type is compatible, no conversion.</span>
myBook.publishedAt = <span class="hljs-string">'1678-10-15 12:00'</span>; <span class="hljs-comment">// new Date( '1678-10-15 12:00' )</span>
myBook.available = some &amp;&amp; weird || condition; <span class="hljs-comment">// Will always be Boolean. Or null.</span>
</code></pre>
<h3 id="record-set-attrname-value-options-options-">record.set( { attrName : value, ... }, options? : <code>options</code> )</h3>
<p>Bulk assign record&#39;s attributes, possibly taking options.</p>
<p>If the value is not compatible with attribute&#39;s type from the declaration, it is converted:</p>
<ul>
<li>with <code>Type( value )</code> call, for primitive types.</li>
<li>with <code>record.attrName.set( value )</code>, for existing record or collection (updated in place).</li>
<li>with <code>new Type( value )</code> in all other cases.</li>
</ul>
<p>Record triggers events after all changes are applied:</p>
<ol>
<li><code>change:attrName</code> <em>( record, val, options )</em> for any changed attribute.</li>
<li><code>change</code> <em>(record, options)</em>, if there were changed attributes.</li>
</ol>
<h3 id="record-assignfrom-otherrecord-">record.assignFrom( otherRecord )</h3>
<p>Makes an existing <code>record</code> to be the full clone of <code>otherRecord</code>, recursively assigning all attributes.
In contracts to <code>record.clone()</code>, the record is updated in place.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Another way of doing the bestSeller.clone()</span>
<span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> Book();
book.assignFrom( bestSeller );
</code></pre>
<h3 id="record-transaction-fun-">record.transaction( fun )</h3>
<p>Execute the all changes made to the record in <code>fun</code> as single transaction triggering the single <code>change</code> event.</p>
<p>All record updates occurs in the scope of transactions. Transaction is the sequence of changes which results in a single <code>change</code> event.
Transaction can be opened either manually or implicitly with calling <code>set()</code> or assigning an attribute.
Any additional changes made to the record in <code>change:attr</code> event handler will be executed in the scope of the original transaction, and won&#39;t trigger additional <code>change</code> events.</p>
<pre><code class="highlight javascript">some.record.transaction( <span class="hljs-function"><span class="hljs-params">record</span> =&gt;</span> {
    record.a = <span class="hljs-number">1</span>; <span class="hljs-comment">// `change:a` event is triggered.</span>
    record.b = <span class="hljs-number">2</span>; <span class="hljs-comment">// `change:b` event is triggered.</span>
}); <span class="hljs-comment">// `change` event is triggered.</span>
</code></pre>
<p>Manual transactions with attribute assignments are superior to <code>record.set()</code> in terms of both performance and flexibility.</p>
<h3 id="attrdef-type-has-get-hook-"><code>attrDef</code> : Type.has.get( <code>hook</code> )</h3>
<p>Attach get hook to the record&#39;s attribute. <code>hook</code> is the function of signature <code>( value, attr ) =&gt; value</code> which is used to transform the attribute&#39;s value <em>before it will be read</em>. Hook is executed in the context of the record.</p>
<h3 id="attrdef-type-has-set-hook-"><code>attrDef</code> : Type.has.set( <code>hook</code> )</h3>
<p>Attach the set hook to the record&#39;s attribute. <code>hook</code> is the function of signature <code>( value, attr ) =&gt; value</code> which is used to transform the attribute&#39;s value <em>before it will be assigned</em>. Hook is executed in the context of the record.</p>
<p>If set hook will return <code>undefined</code>, it will cancel attribute update.</p>
<h2 id="nested-records-and-collections">Nested records and collections</h2>
<p>Record&#39;s attributes can hold other Records and Collections, forming indefinitely nested data structures of arbitrary complexity.
To create nested record or collection you should just mention its constructor function in attribute&#39;s definition.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { Record } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">email</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">isActive</span> : <span class="hljs-literal">true</span>
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersListState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">users</span> : User.Collection
    }
}
</code></pre>
<p>All nested records and collections are <em>aggregated</em> by default and behave as integral parts of the containing record. Aggregated attributes are <em>exclusively owned</em> by the record, and taken with it together form an <em>ownership tree</em>. Many operations are performed recursively on aggregated elements:</p>
<ul>
<li>They are created when the owner record is created.</li>
<li>They are cloned when the record is cloned.</li>
<li>They are disposed when the record is disposed.</li>
<li>They are validated as part of the record.</li>
<li>They are serialized as nested JSON.</li>
</ul>
<p>The nature of aggregation relationship in OO is explained in this <a href="https://medium.com/@gaperton/nestedtypes-2-0-meet-an-aggregation-and-the-rest-of-oo-animals-a9fca7c36ecf">article</a>.</p>
<h3 id="attrdef-recordorcollection"><code>attrDef</code> : RecordOrCollection</h3>
<p>Aggregated record or collection. Represented as nested object or array in record&#39;s JSON. Aggregated members are owned by the record and treated as its <em>integral part</em> (recursively created, cloned, serialized, validated, and disposed).
One object can have single owner. The record with its aggregated attributes forms an <em>aggregation tree</em>.</p>
<p>All changes in aggregated record or collections are detected and cause change events on the containing record.</p>
<h3 id="record-getowner-">record.getOwner()</h3>
<p>Return the record which is an owner of the current record, or <code>null</code> there are no one.</p>
<p>Due to the nature of <em>aggregation</em>, an object may have one and only one owner.</p>
<h3 id="record-collection">record.collection</h3>
<p>Return the collection which aggregates the record, or <code>null</code> if there are no one.</p>
<h3 id="attrdef-recordorcollection-shared"><code>attrDef</code> : RecordOrCollection.shared</h3>
<p>Non-serializable reference to the record or collection possibly from the different aggregation tree. Initialized with <code>null</code>. Is not recursively cloned, serialized, validated, or disposed.</p>
<p>All changes in shared records or collections are detected and cause change events of the containing record.</p>
<aside class="notice">The type of <code>attrDef</code>{ name : defaultValue } is inferred as `Type.shared` if it extends Record or Collection</aside>

<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersListState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">users</span> : User.Collection,
        <span class="hljs-attr">selected</span> : User.shared <span class="hljs-comment">// Can be assigned with the user from this.users</span>
    }
}
</code></pre>
<h3 id="attrdef-collection-refs"><code>attrDef</code> : Collection.Refs</h3>
<p>Non-aggregating collection. Collection of references to shared records which itself is <em>aggregated</em> by the record, but <em>does not aggregate</em> its elements. In contrast to the <code>Collection.shared</code>, <code>Collection.Refs</code> creates an instance of collection which <em>is the part the parent record</em>.</p>
<p>The collection itself is recursively created and cloned. However, its records are not aggregated by the collection thus they are not recursively cloned, validated, serialized, or disposed.</p>
<p>All changes in the collection and its elements are detected and cause change events of the containing record.</p>
<aside class="notice"><code>Collection.Refs</code> is the constructor and can be used to create non-aggregating collection with `new` operator.</aside>

<pre><code class="highlight javascript">    @define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRecord</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
        <span class="hljs-keyword">static</span> attributes = {
            <span class="hljs-attr">notCloned</span> : SomeCollection.shared, <span class="hljs-comment">// Reference to the _shared collection_ object.</span>
            cloned : SomeCollection.Refs <span class="hljs-comment">// _Aggregated_ collection of references to the _shared records_.</span>
    }
</code></pre>
<h3 id="decorator-predefine"><code>decorator</code> @predefine</h3>
<p>Make forward declaration for the record to define its attributes later with <code>RecordClass.define()</code>. Used instead of <code>@define</code> for recursive record definitions.</p>
<p>Creates the default <code>RecordClass.Collection</code> type which can be referenced in attribute definitions.</p>
<h3 id="static-define-attributes-name-attrdef-"><code>static</code> define({ attributes : { name : <code>attrDef</code>, ... } })</h3>
<p>May be called to define attributes in conjunction with <code>@predefine</code> decorator to make recursive record definitions.</p>
<pre><code class="highlight javascript">@predefine <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span></span>{}

Comment.define({
    <span class="hljs-attr">attributes</span> : {
        <span class="hljs-attr">text</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">replies</span> : Comment.Collection
    }
});
</code></pre>
<h1 id="collection">Collection</h1>
<p>Collections are ordered sets of records. You can bind &quot;changes&quot; events to be notified when the collection has been modified, listen for the record &quot;add&quot;,  &quot;remove&quot;, and &quot;change&quot; events, and use a full suite of iteration methods.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Implicitly defined collection.</span>
<span class="hljs-keyword">const</span> books = <span class="hljs-keyword">new</span> Book.Collection();

@define
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComicsShelve</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Book</span>.<span class="hljs-title">Collection</span> </span>{
    <span class="hljs-keyword">static</span> itemEvents = {
        <span class="hljs-comment">// List of records's events we want to be triggered on the collection</span>
        <span class="hljs-string">'change:inMyReadingList'</span> : <span class="hljs-literal">true</span>,
        <span class="hljs-string">'customEvent'</span> : <span class="hljs-literal">true</span>
    }
}

@define
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comics</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Book</span> </span>{
    <span class="hljs-comment">// Use custom collection instead of the implicitly created one</span>
    <span class="hljs-keyword">static</span> Collection = ComicsShelve;

    <span class="hljs-comment">// Extend record's attributes</span>
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">artist</span> : Author
    }
}
</code></pre>
<h2 id="definition">Definition</h2>
<h3 id="recordclass-collection">RecordClass.Collection</h3>
<p>Default collection constructor for the given Record class.</p>
<p><code>MyRecord.Collection</code> is defined automatically for every record class. In most cases, there is no need to define collections explicitly.</p>
<h3 id="collectionclass-refs">CollectionClass.Refs</h3>
<p>Non-aggregating collection constructor.</p>
<p>By default, the collection aggregates its elements, which are treated as an integral part of the collection (serialized, cloned, disposed, and validated recursively). An aggregation means the <em>single owner</em>, as the single object cannot be an integral part of two distinct things.</p>
<p><code>Collection.Refs</code> doesn&#39;t aggregate its elements, and it&#39;s not mapped to JSON. It is useful for the local application state only.</p>
<aside class="notice">
Use the <code>Collection.subsetOf()</code> attribute definition and the <code>collection.createSubset()</code> factory method to create the collection which should be mapped to JSON.
</aside>

<h3 id="static-model-recordconstructor"><code>static</code> model = RecordConstructor</h3>
<p>Part of the collection&#39;s definition specifying the record type. The collection must know the type of its records to restore its elements from JSON properly.</p>
<p>When not specified, the collection can hold any Record subclass, but it cannot deserialize itself.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span>.<span class="hljs-title">Collection</span> </span>{
    <span class="hljs-keyword">static</span> model = Book;
}
</code></pre>
<h3 id="static-comparator-attrname-"><code>static</code> comparator = &#39;attrName&#39;</h3>
<p>Maintain the collection in sorted order by the given record&#39;s attribute.</p>
<h3 id="static-comparator-x-number-string"><code>static</code> comparator = x =&gt; number | string</h3>
<p>Maintain the collection in sorted order according to the &quot;sortBy&quot; comparator function.</p>
<p>&quot;sortBy&quot; comparator functions take a record and return a numeric or string value by which the record should be ordered relative to others.</p>
<h3 id="static-comparator-x-y-1-0-1"><code>static</code> comparator = ( x, y ) =&gt; -1 | 0 | 1</h3>
<p>Maintain the collection in sorted order according to the &quot;sort&quot; comparator function.</p>
<p>&quot;sort&quot; comparator functions take two records, and return -1 if the first record should come before the second, 0 if they are of the same rank and 1 if the first record should come after.</p>
<p>Note how even though all of the chapters in this example are added backwards, they come out in the proper order:</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">page</span> : <span class="hljs-built_in">Number</span>,
        <span class="hljs-attr">title</span> : <span class="hljs-built_in">String</span>
    }
}

<span class="hljs-keyword">var</span> chapters = <span class="hljs-keyword">new</span> Chapter.Collection();

chapters.comparator = <span class="hljs-string">'page'</span>;

chapters.add(<span class="hljs-keyword">new</span> Chapter({<span class="hljs-attr">page</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"The End"</span>}));
chapters.add(<span class="hljs-keyword">new</span> Chapter({<span class="hljs-attr">page</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"The Middle"</span>}));
chapters.add(<span class="hljs-keyword">new</span> Chapter({<span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"The Beginning"</span>}));

alert(chapters.map( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.title ));
</code></pre>
<h2 id="create-and-dispose">Create and dispose</h2>
<h3 id="new-collection-records-options-">new Collection( records?, options? )</h3>
<p>Create an aggregating serializable collection of records. The collection will take an ownership on its records and will put an error in the console if it can&#39;t.</p>
<p>When creating a Collection, you may choose to pass in the initial array of records. The collection&#39;s comparator may be included as an option. Passing <code>false</code> as the comparator option will prevent sorting. If you define an <code>initialize()</code> function, it will be invoked when the collection is created.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">var</span> tabs = <span class="hljs-keyword">new</span> TabSet([tab1, tab2, tab3]);
</code></pre>
<h3 id="new-collection-refs-records-options-">new Collection.Refs( records?, options? )</h3>
<p>Create a non-aggregating non-serializable collection. The collection does not take ownership in its records. In all other aspects it behaves as the regular collection.</p>
<h3 id="callback-collection-initialize-records-options-"><code>callback</code> collection.initialize( records?, options? )</h3>
<p>Initialization function which is called at the end of the constructor.</p>
<h3 id="collection-clone-">collection.clone()</h3>
<p>Clone the collection. Aggregating collection will be recursively cloned, non-aggregated collections will be shallow cloned.</p>
<h3 id="collection-dispose-">collection.dispose()</h3>
<p>Dispose the collection. Aggregating collection will recursively dispose its records.</p>
<h2 id="read-and-iterate">Read and iterate</h2>
<h3 id="collection-get-id-">collection.get( id )</h3>
<p>Get a record from a collection, specified by an <code>id</code>, a <code>cid</code>, or by passing in a record.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> book = library.get(<span class="hljs-number">110</span>);
</code></pre>
<h3 id="collection-at-index-">collection.at( index )</h3>
<p>Get a record from a collection, specified by index. Useful if your collection is sorted, and if your collection isn&#39;t sorted, at will still retrieve records in insertion order. When passed a negative index, it will retrieve the record from the back of the collection.</p>
<h3 id="collection-length">collection.length</h3>
<p>Like an array, a Collection maintains a length property, counting the number of records it contains.</p>
<h3 id="collection-models">collection.models</h3>
<p>Raw access to the JavaScript array of records inside of the collection. Usually you&#39;ll want to use <code>get</code>, <code>at</code>, or the other methods to access record objects, but occasionally a direct reference to the array is desired.</p>
<h3 id="collection-slice-begin-end-">collection.slice( begin, end )</h3>
<p>Return a shallow copy of the <code>collection.models</code>, using the same options as native Array#slice.</p>
<h3 id="collection-indexof-recordorid-any-number">collection.indexOf( recordOrId : any ) : number</h3>
<p>Return an index of the record in the collection, and -1 if there are no such a record in the collection.</p>
<p>Can take the record itself as an argument, <code>id</code>, or <code>cid</code> of the record.</p>
<h3 id="collection-foreach-iteratee-val-record-index-void-context-">collection.forEach( iteratee : ( val : Record, index ) =&gt; void, context? )</h3>
<p>Same as <code>collection.each()</code>.</p>
<h3 id="collection-each-iteratee-val-record-index-void-context-">collection.each( iteratee : ( val : Record, index ) =&gt; void, context? )</h3>
<p>Iterate through the elements of the collection. Similar to <code>Array.forEach</code>.</p>
<aside class="notice">Use <code>collection.updateEach( iteratee, index )</code> method to update records in a loop.</aside>

<h3 id="collection-map-iteratee-val-record-index-t-context-">collection.map( iteratee : ( val : Record, index ) =&gt; T, context? )</h3>
<p>Map elements of the collection. Similar to <code>Array.map</code>, but <code>undefined</code> values returned by iteratee are filtered out.</p>
<p>Thus, <code>collection.map</code> can be used to map and filter elements in a single pass.</p>
<h3 id="collection-filter-iteratee-predicate-context-">collection.filter( iteratee : Predicate, context? )</h3>
<p>Return filtered array of records matching the predicate.</p>
<p>Predicate is either the iteratee function returning boolean, or an object with attribute values used to match with record&#39;s attributes.</p>
<h3 id="collection-every-iteratee-predicate-context-boolean">collection.every( iteratee : Predicate, context? ) : boolean</h3>
<p>Return <code>true</code> if all records match the predicate.</p>
<h3 id="collection-some-iteratee-predicate-context-boolean">collection.some( iteratee : Predicate, context? ) : boolean</h3>
<p>Return <code>true</code> if at least one record match the predicated.</p>
<p>By default there is no comparator for a collection. If you define a comparator, it will be used to maintain the collection in sorted order. This means that as records are added, they are inserted at the correct index in <code>collection.models</code>.</p>
<p>Note that Type-R depends on the arity of your comparator function to determine between the two styles, so be careful if your comparator function is bound.</p>
<p>Collections with a comparator will not automatically re-sort if you later change record attributes, so you may wish to call sort after changing record attributes that would affect the order.</p>
<h2 id="update">Update</h2>
<p>Methods to update the collection. They accept common options:</p>
<ul>
<li><code>sort : false</code> - do not sort the collection.</li>
<li><code>parse : true</code> - parse raw JSON (used to set collection with a data from the server).</li>
</ul>
<h3 id="collection-add-records-options-">collection.add( records, options? )</h3>
<p>Add a record (or an array of records) to the collection. If this is the <code>Record.Collection</code>, you may also pass raw attributes objects, and have them be vivified as instances of the <code>Record</code>. Returns the added (or preexisting, if duplicate) records.</p>
<p>Pass <code>{at: index}</code> to splice the record into the collection at the specified index. If you&#39;re adding records to the collection that are already in the collection, they&#39;ll be ignored, unless you pass <code>{merge: true}</code>, in which case their attributes will be merged into the corresponding records.</p>
<ol>
<li>Trigger the one event per record:<ul>
<li><code>add</code>(record, collection, options) for each record added.</li>
<li><code>change</code>(record, options) for each record changed (if the <code>{merge: true}</code> option is passed).</li>
</ul>
</li>
<li>Trigger the single event:<ul>
<li><code>update</code>(collection, options) if any records were added.</li>
<li><code>sort</code>(collection, options) if an order of records was changed.</li>
</ul>
</li>
<li>Trigger <code>changes</code> event in case if any changes were made to the collection and objects inside.</li>
</ol>
<h3 id="collection-remove-records-options-">collection.remove( records, options? )</h3>
<p>Remove a record (or an array of records) from the collection, and return them. Each record can be a record instance, an id string or a JS object, any value acceptable as the id argument of collection.get.</p>
<ol>
<li>Trigger <code>remove</code>(record, collection, options) for each record removed.</li>
<li>If any records were removed, trigger:<ul>
<li><code>update</code>(collection, options)</li>
<li><code>changes</code>(collection, options).</li>
</ul>
</li>
</ol>
<h3 id="collection-set-records-options-">collection.set( records, options? )</h3>
<p>The set method performs a &quot;smart&quot; update of the collection with the passed list of records. If a record in the list isn&#39;t yet in the collection it will be added; if the record is already in the collection its attributes will be merged; and if the collection contains any records that aren&#39;t present in the list, they&#39;ll be removed. All of the appropriate &quot;add&quot;, &quot;remove&quot;, and &quot;change&quot; events are fired as this happens. Returns the touched records in the collection. If you&#39;d like to customize the behavior, you can disable it with options: <code>{remove: false}</code>, or <code>{merge: false}</code>.</p>
<h4 id="events">Events</h4>
<ol>
<li>Trigger the one event per record:<ul>
<li><code>add</code>(record, collection, options) for each record added.</li>
<li><code>remove</code>(record, collection, options) for each record removed.</li>
<li><code>change</code>(record, options) for each record changed.</li>
</ul>
</li>
<li>Trigger the single event:<ul>
<li><code>update</code>(collection, options) if any records were added.</li>
<li><code>sort</code>(collection, options) if an order of records was changed.</li>
</ul>
</li>
<li>Trigger <code>changes</code> event in case if any changes were made to the collection and objects inside.</li>
</ol>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> vanHalen = <span class="hljs-keyword">new</span> Man.Collection([ eddie, alex, stone, roth ]);

vanHalen.set([ eddie, alex, stone, hagar ]);

<span class="hljs-comment">// Fires a "remove" event for roth, and an "add" event for hagar.</span>
<span class="hljs-comment">// Updates any of stone, alex, and eddie's attributes that may have</span>
<span class="hljs-comment">// changed over the years.</span>
</code></pre>
<h3 id="collection-assignfrom-othercollection-">collection.assignFrom( otherCollection )</h3>
<p>Synchronize the state of the collection and its aggregation tree with other collection of the same type. Updates existing objects in place. Record in the collection is considered to be &quot;existing&quot; if it has the same <code>id</code>.</p>
<p>Equivalent to <code>collection.set( otherCollection.models, { merge : true } )</code> and triggers similar events on change.</p>
<h3 id="collection-reset-records-options-">collection.reset( records, options? )</h3>
<p>Replace the collection&#39;s content with the new records. More efficient than <code>collection.set</code>, but does not send record-level events.</p>
<p>Calling <code>collection.reset()</code> without passing any records as arguments will empty the entire collection.</p>
<ol>
<li>Trigger event <code>reset</code>( collection, options ).</li>
<li>Trigger event <code>changes</code>( collection, options ).</li>
</ol>
<h3 id="collection-sort-options-">collection.sort( options? )</h3>
<p>Force a collection to re-sort itself. You don&#39;t need to call this under normal circumstances, as a collection with a comparator will sort itself whenever a record is added. To disable sorting when adding a record, pass <code>{sort: false}</code> to add. Calling sort triggers a &quot;sort&quot; event on the collection.</p>
<h3 id="collection-push-record-options-">collection.push( record, options? )</h3>
<p>Add a record at the end of a collection. Takes the same options as add.</p>
<h3 id="collection-pop-options-">collection.pop( options? )</h3>
<p>Remove and return the last record from a collection. Takes the same options as remove.</p>
<h3 id="collection-unshift-record-options-">collection.unshift( record, options? )</h3>
<p>Add a record at the beginning of a collection. Takes the same options as add.</p>
<h3 id="collection-shift-options-">collection.shift( options? )</h3>
<p>Remove and return the first record from a collection. Takes the same options as remove.</p>
<h1 id="observable-changes">Observable Changes</h1>
<h2 id="overview">Overview</h2>
<p>Type-R implements <em>deeply observable changes</em> on the object graph constructed of records and collection.</p>
<p>All of the record and collection updates happens in a scope of the transaction followed by the change event. Every record or collection update operation opens <em>implicit</em> transaction. Several update operations can be groped to the single <em>explicit</em> transaction if executed in the scope of the <code>obj.transaction()</code> or <code>col.updateEach()</code> call.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-string">''</span>
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-string">''</span>,
        <span class="hljs-attr">datePublished</span> : <span class="hljs-built_in">Date</span>,
        <span class="hljs-attr">author</span> : Author
    }
}

<span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> Book();
book.on( <span class="hljs-string">'change'</span>, () =&gt; <span class="hljs-built_in">console</span>.log( <span class="hljs-string">'Book is changed'</span>) );

<span class="hljs-comment">// Implicit transaction, prints to the console</span>
book.author.name = <span class="hljs-string">'John Smith'</span>;
</code></pre>
<h2 id="record">Record</h2>
<h3 id="events-mixin-methods-7-">Events mixin methods (7)</h3>
<p>Record implements <a href="#events-mixin">Events</a> mixin.</p>
<h3 id="event-change-record-"><code>event</code> &quot;change&quot; ( record )</h3>
<p>Triggered by the record at the end of the attributes update transaction in case if there were any changes applied.</p>
<h3 id="event-change-attrname-record-value-"><code>event</code> &quot;change:attrName&quot; ( record, value )</h3>
<p>Triggered by the record during the attributes update transaction for every changed attribute.</p>
<h3 id="attrdef-type-has-watcher-watcher-"><code>attrDef</code> : Type.has.watcher( watcher )</h3>
<p>Attach <code>change:attr</code> event listener to the particular record&#39;s attribute. <code>watcher</code> can either be the record&#39;s method name or the function <code>( newValue, attr ) =&gt; void</code>. Watcher is always executed in the context of the record.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>.has.watcher( <span class="hljs-string">'onNameChange'</span> ),
        <span class="hljs-attr">isAdmin</span> : <span class="hljs-built_in">Boolean</span>,
    }

    onNameChange(){
        <span class="hljs-comment">// Cruel. But we need it for the purpose of the example.</span>
        <span class="hljs-keyword">this</span>.isAdmin = <span class="hljs-keyword">this</span>.name.indexOf( <span class="hljs-string">'Admin'</span> ) &gt;= <span class="hljs-number">0</span>;
    }
}
</code></pre>
<h3 id="attrdef-type-has-changeevents-false-"><code>attrDef</code> : Type.has.changeEvents( false )</h3>
<p>Turn off changes observation for nested records or collections.</p>
<p>Record automatically listens to change events of all nested records and collections, triggering appropriate change events for its attributes. This declaration turns it off for the specific attribute.</p>
<h3 id="attrdef-type-has-events-eventname-handler-"><code>attrDef</code> : Type.has.events({ eventName : handler, ... })</h3>
<p>Automatically manage custom event subscription for the attribute. <code>handler</code> is either the method name or the handler function.</p>
<h3 id="record-changed">record.changed</h3>
<p>The <code>changed</code> property is the internal hash containing all the attributes that have changed during its last transaction.
Please do not update <code>changed</code> directly since its state is internally maintained by <code>set()</code>.
A copy of <code>changed</code> can be acquired from <code>changedAttributes()</code>.</p>
<h3 id="record-changedattributes-attrs-">record.changedAttributes( attrs? )</h3>
<p>Retrieve a hash of only the record&#39;s attributes that have changed during the last transaction,
or false if there are none. Optionally, an external attributes hash can be passed in,
returning the attributes in that hash which differ from the record.
This can be used to figure out which portions of a view should be updated,
or what calls need to be made to sync the changes to the server.</p>
<h3 id="record-previous-attr-">record.previous( attr )</h3>
<p>During a &quot;change&quot; event, this method can be used to get the previous value of a changed attribute.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span></span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>
    }
}

<span class="hljs-keyword">const</span> bill = <span class="hljs-keyword">new</span> Person({
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Bill Smith"</span>
});

bill.on(<span class="hljs-string">"change:name"</span>, ( record, name ) =&gt; {
  alert( <span class="hljs-string">`Changed name from <span class="hljs-subst">${ bill.previous(<span class="hljs-string">'name'</span>) }</span> to <span class="hljs-subst">${ name }</span>`</span>);
});

bill.name = <span class="hljs-string">"Bill Jones"</span>;
</code></pre>
<h3 id="record-previousattributes-">record.previousAttributes()</h3>
<p>Return a copy of the record&#39;s previous attributes. Useful for getting a diff between versions of a record, or getting back to a valid state after an error occurs.</p>
<h2 id="collection">Collection</h2>
<p>All changes in the records cause change events in the collections they are contained in.</p>
<p>Subset collections is an exception; they don&#39;t observe changes of its elements by default.</p>
<h3 id="events-mixin-methods-7-">Events mixin methods (7)</h3>
<p>Collection implements <a href="#events-mixin">Events</a> mixin.</p>
<h3 id="collection-transaction-fun-">collection.transaction( fun )</h3>
<p>Execute the sequence of updates in <code>fun</code> function in the scope of the transaction.</p>
<p>All collection updates occurs in the scope of transactions. Transaction is the sequence of changes which results in a single <code>changes</code> event.</p>
<p>Transaction can be opened either manually or implicitly with calling any of collection update methods.
Any additional changes made to the collection or its items in event handlers will be executed in the scope of the original transaction, and won&#39;t trigger an additional <code>changes</code> events.</p>
<h3 id="collection-updateeach-iteratee-val-record-index-void-context-">collection.updateEach( iteratee : ( val : Record, index ) =&gt; void, context? )</h3>
<p>Similar to the <code>collection.each</code>, but wraps an iteration in a transaction. The single <code>changes</code> event will be emitted for the group of changes to the records made in <code>updateEach</code>.</p>
<h3 id="static-itemevents-eventname-handler-"><code>static</code> itemEvents = { eventName : <code>handler</code>, ... }</h3>
<p>Subscribe for events from records. The <code>hander</code> is either the collection&#39;s method name, the handler function, or <code>true</code>.</p>
<p>When <code>true</code> is passed as a handler, the corresponding event will be triggered on the collection.</p>
<h3 id="event-changes-collection-options-"><code>event</code> &quot;changes&quot; (collection, options)</h3>
<p>When collection has changed. Single event triggered when the collection has been changed.</p>
<h3 id="event-reset-collection-options-"><code>event</code> &quot;reset&quot; (collection, options)</h3>
<p>When the collection&#39;s entire contents have been reset (<code>reset()</code> method was called).</p>
<h3 id="event-update-collection-options-"><code>event</code> &quot;update&quot; (collection, options)</h3>
<p>Single event triggered after any number of records have been added or removed from a collection.</p>
<h3 id="event-sort-collection-options-"><code>event</code> &quot;sort&quot; (collection, options)</h3>
<p>When the collection has been re-sorted.</p>
<h3 id="event-add-record-collection-options-"><code>event</code> &quot;add&quot; (record, collection, options)</h3>
<p>When a record is added to a collection.</p>
<h3 id="event-remove-record-collection-options-"><code>event</code> &quot;remove&quot; (record, collection, options)</h3>
<p>When a record is removed from a collection.</p>
<h3 id="event-change-record-options-"><code>event</code> &quot;change&quot; (record, options)</h3>
<p>When a record inside of the collection is changed.</p>
<h2 id="events-mixin">Events mixin</h2>
<p>Type-R uses an efficient synchronous events implementation which is backward compatible with Backbone 1.1 Events API but is about twice faster in all major browsers. It comes in form of <code>Events</code> mixin and the <code>Messenger</code> base class.</p>
<p><code>Events</code> is a <a href="#mixins">mixin</a> giving the object the ability to bind and trigger custom named events. Events do not have to be declared before they are bound, and may take passed arguments.</p>
<p>Both <code>source</code> and <code>listener</code> mentioned in method signatures must implement Events methods.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { mixins, Events } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

@mixins( Events )
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventfulClass</span> </span>{
    ...
}
</code></pre>
<aside class="notice">There's the <code>Messenger</code> abstract base class with Events mixed in.</aside>

<h3 id="source-trigger-event-arg1-arg2-">source.trigger(event, arg1, arg2, ... )</h3>
<p>Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be passed along to the event callbacks.</p>
<h3 id="listener-listento-source-event-callback-">listener.listenTo(source, event, callback)</h3>
<p>Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can be removed all at once later on. The callback will always be called with object as context.</p>
<pre><code class="highlight javascript">    view.listenTo(record, <span class="hljs-string">'change'</span>, view.render );
</code></pre>
<aside class="success">Subscriptions made with <code>listenTo()</code> will be stopped automatically if an object is properly disposed (<code>dispose()</code> method is called).</aside>

<h3 id="listener-stoplistening-source-event-callback-">listener.stopListening([source], [event], [callback])</h3>
<p>Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove all of its registered callbacks ... or be more precise by telling it to remove just the events it&#39;s listening to on a specific object, or a specific event, or just a specific callback.</p>
<pre><code class="highlight javascript">    view.stopListening(); <span class="hljs-comment">// Unsubscribe from all events</span>

    view.stopListening(record); <span class="hljs-comment">// Unsubscribe from all events from the record</span>
</code></pre>
<aside class="notice">Messenger, Record, Collection, and Store execute <code>this.stopListening()</code> from their <code>dispose()</code> method. You don't have to unsubscribe from events explicitly if you are using <code>listenTo()</code> method and disposing your objects properly.</aside>

<h3 id="listener-listentoonce-source-event-callback-">listener.listenToOnce(source, event, callback)</h3>
<p>Just like <code>listenTo()</code>, but causes the bound callback to fire only once before being automatically removed.</p>
<h3 id="source-on-event-callback-context-">source.on(event, callback, [context])</h3>
<p>Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a large number of different events on a page, the convention is to use colons to namespace them: <code>poll:start</code>, or <code>change:selection</code>. The event string may also be a space-delimited list of several events...</p>
<pre><code class="highlight javascript">    book.on(<span class="hljs-string">"change:title change:author"</span>, ...);
</code></pre>
<p>Callbacks bound to the special &quot;all&quot; event will be triggered when any event occurs, and are passed the name of the event as the first argument. For example, to proxy all events from one object to another:</p>
<pre><code class="highlight javascript">    proxy.on(<span class="hljs-string">"all"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventName</span>) </span>{
        object.trigger(eventName);
    });
</code></pre>
<p>All event methods also support an event map syntax, as an alternative to positional arguments:</p>
<pre><code class="highlight javascript">    book.on({
        <span class="hljs-string">"change:author"</span>: authorPane.update,
        <span class="hljs-string">"change:title change:subtitle"</span>: titleView.update,
        <span class="hljs-string">"destroy"</span>: bookView.remove
    });
</code></pre>
<p>To supply a context value for this when the callback is invoked, pass the optional last argument: <code>record.on(&#39;change&#39;, this.render, this)</code> or <code>record.on({change: this.render}, this)</code>.</p>
<aside class="warning">Event subscription with <code>source.on()</code> may create memory leaks if it's not stopped properly with <code>source.off()</code></aside>

<h3 id="source-off-event-callback-context-">source.off([event], [callback], [context])</h3>
<p>Remove a previously bound callback function from an object. If no context is specified, all of the versions of the callback with different contexts will be removed. If no callback is specified, all callbacks for the event will be removed. If no event is specified, callbacks for all events will be removed.</p>
<pre><code class="highlight javascript">    <span class="hljs-comment">// Removes just the `onChange` callback.</span>
    object.off(<span class="hljs-string">"change"</span>, onChange);

    <span class="hljs-comment">// Removes all "change" callbacks.</span>
    object.off(<span class="hljs-string">"change"</span>);

    <span class="hljs-comment">// Removes the `onChange` callback for all events.</span>
    object.off(<span class="hljs-literal">null</span>, onChange);

    <span class="hljs-comment">// Removes all callbacks for `context` for all events.</span>
    object.off(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, context);

    <span class="hljs-comment">// Removes all callbacks on `object`.</span>
    object.off();
</code></pre>
<p>Note that calling <code>record.off()</code>, for example, will indeed remove all events on the record — including events that Backbone uses for internal bookkeeping.</p>
<h3 id="source-once-event-callback-context-">source.once(event, callback, [context])</h3>
<p>Just like <code>on()</code>, but causes the bound callback to fire only once before being removed. Handy for saying &quot;the next time that X happens, do this&quot;. When multiple events are passed in using the space separated syntax, the event will fire once for every event you passed in, not once for a combination of all events</p>
<h3 id="built-in-events">Built-in events</h3>
<p>All Type-R objects implement Events mixin and use events to notify listeners on changes.</p>
<p>Record and Store change events:</p>
<table>
<thead>
<tr>
<th>Event name</th>
<th>Handler arguments</th>
<th>When triggered</th>
</tr>
</thead>
<tbody>
<tr>
<td>change</td>
<td>(record, options)</td>
<td>At the end of any changes.</td>
</tr>
<tr>
<td>change:attrName</td>
<td>(record, value, options)</td>
<td>The record&#39;s attribute has been changed.</td>
</tr>
</tbody>
</table>
<p>Collection change events:</p>
<table>
<thead>
<tr>
<th>Event name</th>
<th>Handler arguments</th>
<th>When triggered</th>
</tr>
</thead>
<tbody>
<tr>
<td>changes</td>
<td>(collection, options)</td>
<td>At the end of any changes.</td>
</tr>
<tr>
<td>reset</td>
<td>(collection, options)</td>
<td><code>reset()</code> method was called.</td>
</tr>
<tr>
<td>update</td>
<td>(collection, options)</td>
<td>Any records added or removed.</td>
</tr>
<tr>
<td>sort</td>
<td>(collection, options)</td>
<td>Order of records is changed. </td>
</tr>
<tr>
<td>add</td>
<td>(record, collection, options)</td>
<td>The record is added to a collection.</td>
</tr>
<tr>
<td>remove</td>
<td>(record, collection, options)</td>
<td>The record is removed from a collection.</td>
</tr>
<tr>
<td>change</td>
<td>(record, options)</td>
<td>The record is changed inside of collection.</td>
</tr>
</tbody>
</table>
<h2 id="messenger-class">Messenger class</h2>
<p>Messenger is an abstract base class implementing Events mixin and some convenience methods.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { define, Messenger } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessenger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Messenger</span> </span>{

}
</code></pre>
<h3 id="events-mixin-methods-7-">Events mixin methods (7)</h3>
<p>Messenger implements <a href="#events-mixin">Events</a> mixin.</p>
<h3 id="messenger-cid">messenger.cid</h3>
<p>Unique run-time only messenger instance id (string).</p>
<h3 id="callback-messenger-initialize-"><code>callback</code> messenger.initialize()</h3>
<p>Callback which is called at the end of the constructor.</p>
<h3 id="messenger-dispose-">messenger.dispose()</h3>
<p>Executes <code>messenger.stopListening()</code> and <code>messenger.off()</code>.</p>
<p>Objects must be disposed to prevent memory leaks caused by subscribing for events from singletons.</p>
<h1 id="validation">Validation</h1>
<h2 id="overview">Overview</h2>
<p>Type-R validation mechanics based on following principles:</p>
<ul>
<li>Validation is performed recursively on the aggregation tree formed by nested records and collections. If an element at the bottom of the tree is not valid, the whole object tree is not valid.</li>
<li>Validation rules can be defined for record&#39;s attribute, record, and collection.</li>
<li>Validation happens automatically on the first read of the validation error. There&#39;s no special API to trigger the validation.</li>
<li>Validation results are cached across the aggregation tree, thus consequent validation error reads are fast. Changed parts of aggregation tree will be validated again when necessary.</li>
</ul>
<h2 id="record-s-attributes">Record&#39;s attributes</h2>
<h3 id="attrdef-type-has-check-predicate-errormsg-"><code>attrDef</code> : Type.has.check( predicate, errorMsg? )</h3>
<p>Attribute-level validator.</p>
<ul>
<li><code>predicate : value =&gt; boolean</code> is the function taking attribute&#39;s value and returning <code>true</code> whenever the value is valid.</li>
<li>optional <code>errorMsg</code> is the error message which will be passed in case if the validation fail.</li>
</ul>
<p>If <code>errorMsg</code> is omitted, error message will be taken from <code>predicate.error</code>. It makes possible to define reusable validation functions.</p>
<pre><code class="highlight javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAge</span>(<span class="hljs-params"> years </span>)</span>{
    <span class="hljs-keyword">return</span> years &gt;= <span class="hljs-number">0</span> &amp;&amp; years &lt; <span class="hljs-number">200</span>;
}

isAge.error = <span class="hljs-string">"Age must be between 0 and 200"</span>;
</code></pre>
<p>Attribute may have any number of checks attached, which are execute in sequence. Validation stops when first check in sequence fails.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Define new attribute metatype encapsulating validation checks.</span>
<span class="hljs-keyword">const</span> Age = <span class="hljs-built_in">Number</span>.has
                .check( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt;= <span class="hljs-number">0</span>, <span class="hljs-string">'I guess you are a bit older'</span> )
                .check( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &lt; <span class="hljs-number">200</span>, <span class="hljs-string">'No way man can be that old'</span> );
</code></pre>
<h3 id="attrdef-type-isrequired"><code>attrDef</code> : Type.isRequired</h3>
<p>The special case of attribute-level check cutting out empty values. Attribute value must be truthy to pass, <code>&quot;Required&quot;</code> is used as validation error.</p>
<p><code>isRequired</code> is the first validator to check, no matter in which order validators were attached.</p>
<h3 id="rec-isvalid-attrname-">rec.isValid( attrName )</h3>
<p>Returns <code>true</code> if the specified record&#39;s attribute is valid.</p>
<h3 id="rec-getvalidationerror-attrname-">rec.getValidationError( attrName )</h3>
<p>Return the validation error for the given attribute or <code>null</code> if it&#39;s valid.</p>
<h2 id="record-and-collection">Record and Collection</h2>
<p>Record and Collection share the same validation API. <code>key</code> is the attribute name for the record and record&#39;s id/cid for the collection.</p>
<h3 id="callback-obj-validate-"><code>callback</code> obj.validate()</h3>
<p>Override this method in subclass to define object-level validation rules. Whatever is returned from <code>validate()</code> is treated as validation error.</p>
<aside class="notice">Do not call this method directly, that's not the way how validation works.</aside>

<h3 id="obj-isvalid-">obj.isValid()</h3>
<p>Returns <code>true</code> if the object is valid. Has same effect as <code>!object.validationError</code>.</p>
<h3 id="obj-isvalid-key-">obj.isValid( key )</h3>
<p>Returns <code>true</code> if the specified record&#39;s attribute or collection element is valid. <code>key</code> is an attribute&#39;s name for the record or record&#39;s id/cid for the collection.</p>
<h3 id="obj-validationerror">obj.validationError</h3>
<p><code>null</code> if an object is valid, or the the ValidationError object with detailed information on validation results.</p>
<p>ValidationError object has following shape:</p>
<pre><code class="highlight javascript">{
    <span class="hljs-attr">error</span> : <span class="hljs-comment">/* as returned from collection.validate() */</span>,

    <span class="hljs-comment">// Members validation errors.</span>
    nested : {
        <span class="hljs-comment">// key is an attrName for the record, and record.cid for the collcation</span>
        key : validationError,
        ...
    }
}
</code></pre>
<h3 id="obj-getvalidationerror-key-">obj.getValidationError( key )</h3>
<p>Return the validation error for the given attribute or collection&#39;s item.
<code>key</code> is an attribute&#39;s name for the record or record&#39;s id/cid for the collection.</p>
<h3 id="obj-eachvalidationerror-iteratee-error-key-obj-void-">obj.eachValidationError( iteratee : ( error, key, obj ) =&gt; void )</h3>
<p>Recursively traverse aggregation tree validation errors. <code>key</code> is <code>null</code> for the object-level validation error returned by <code>obj.validate()</code>.
<code>obj</code> is the reference to the current object.</p>
<h1 id="i-o-and-serialization">I/O and Serialization</h1>
<h2 id="overview">Overview</h2>
<p>Type-R implements generalized IO on top of the <code>IOEndpoint</code> interface,  with JSON serialization handled by Record and Collection classes.</p>
<p>IOEndpoint defines the set of CRUD + list methods operating on raw JSON.
Attachment of an endpoint to the record or collection enables I/O API.  There are few endpoints bundled with Type-R, for instance <code>memoryIO()</code> which can be used for mock testing.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = memoryIO();

    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-string">''</span>,
        <span class="hljs-attr">email</span> : <span class="hljs-string">''</span>
    }
}

<span class="hljs-keyword">const</span> users = <span class="hljs-keyword">new</span> User.Collection();
users
    .add({ <span class="hljs-attr">name</span> : <span class="hljs-string">'John'</span> })
    .save()
    .then( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log( user.id );
</code></pre>
<h2 id="i-o-api">I/O API</h2>
<h3 id="static-endpoint"><code>static</code> endpoint</h3>
<p>I/O endpoint declaration which should be used in Record or Collection definition to enable I/O API.</p>
<p>If an endpoint is defined for the <code>MyRecord</code>, it&#39;s automatically defined for the corresponding <code>MyRecord.Collection</code> as well.</p>
<h3 id="attrdef-type-has-endpoint-endpoint-"><code>attrDef</code> : Type.has.endpoint( <code>endpoint</code> )</h3>
<p>Override or define an I/O endpoint for the specific record&#39;s attribute.</p>
<h3 id="obj-getendpoint-">obj.getEndpoint()</h3>
<p>Returns an object&#39;s IO endpoint. Normally, this is an endpoint which is defined in object&#39;s <code>static endpoint = ...</code> declaration, but it might be overridden by the parent&#39;s record using <code>Type.has.endpoint( ... )</code> attribute declaration.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = restfulIO( <span class="hljs-string">'/api/users'</span> );
    ...
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRole</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = restfulIO( <span class="hljs-string">'/api/roles'</span> );
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-comment">// Use the relative path '/api/roles/:id/users'</span>
        users : User.Collection.has.endpoint( restfulIO( <span class="hljs-string">'./users'</span> ) ),
        ...
    }
}
</code></pre>
<h3 id="record-fetch-options-">record.fetch( options? )</h3>
<p>Asynchronously fetch the record using <code>endpoint.read()</code> method. Returns an abortable ES6 promise.</p>
<p>An endpoint must be defined for the record in order to use that method.</p>
<h3 id="record-save-options-">record.save( options? )</h3>
<p>Asynchronously save the record using <code>endpoint.create()</code> (if there are no id) or <code>endpoint.update()</code> (if id is present) method. Returns an abortable ES6 promise.</p>
<p>An endpoint must be defined for the record in order to use that method.</p>
<h3 id="record-destroy-options-">record.destroy( options? )</h3>
<p>Asynchronously destroy the record using <code>endpoint.destroy()</code> method. Returns an abortable ES6 promise. The record is removed from the aggregating collection upon the completion of the I/O request.</p>
<p>An endpoint must be defined for the record in order to use that method.</p>
<h3 id="collection-fetch-options-">collection.fetch( options? )</h3>
<p>Fetch the collection. Returns an abortable promise.</p>
<p><code>options</code> accepts an optional <code>liveUpdates</code> parameter. When <code>true</code>, collection subscribes for the live updates when I/O is finished.</p>
<h3 id="collection-liveupdates-true-false-">collection.liveUpdates( true | false )</h3>
<p>Subscribe for the live data updates if an I/O endpoint supports it (<code>subscribe()</code>/<code>unsubscribe()</code> IOEndpoint methods).</p>
<aside class="notice">
No built-in I/O enpoints support that functionality yet.
</aside>

<h3 id="obj-haspendingio-">obj.hasPendingIO()</h3>
<p>Returns an abortable promise if there&#39;s any I/O pending with the object, or <code>null</code> otherwise.</p>
<p>Can be used to check for active I/O in progress or to abort pending I/O operation. Please note, that all pending I/O is aborted automatically when new I/O operation is started or an object is disposed. When I/O is aborted, the promise is rejected.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> promise = users.hasPendingIO();
<span class="hljs-keyword">if</span>( promise &amp;&amp; promise.abort ) promise.abort();
</code></pre>
<h2 id="i-o-endpoints">I/O endpoints</h2>
<h3 id="restfulio-url-options-">restfulIO( url, options? )</h3>
<p>HTTP REST client endpoint. Requires <code>window.fetch</code> available natively or through the polyfill. Implements standard BackboneJS REST semantic.</p>
<p>All I/O methods append an optional <code>options.params</code> object to the URL parameters translating them to string with <code>JSON.stringify()</code>.</p>
<ul>
<li><code>record.save()</code> makes:<ul>
<li><code>POST url</code>, if the model has no id. Expects to receive <code>{ id : recordId }</code>.</li>
<li><code>PUT url/:id</code>, if the model has an id.</li>
</ul>
</li>
<li><code>collection.fetch()</code> makes <code>GET url</code>.</li>
<li><code>record.destroy()</code> makes <code>DELETE url</code>.</li>
</ul>
<p>Supports URI relative to owner (<code>./relative/url</code> resolves as <code>/owner/:id/relative/url/:id</code> ).</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { restfulIO } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r/endpoints/restful'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = restfulIO( <span class="hljs-string">'/api/roles'</span> );
    ...
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = restfulIO( <span class="hljs-string">'/api/users'</span> );

    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-comment">// Roles collection here has relative url /api/users/:user_id/roles/</span>
        roles : Role.Collection.has.endpoint( restfulIO( <span class="hljs-string">'./roles'</span> ) ), 
        ...
    }
}
</code></pre>
<h3 id="memoryio-mockdata-delay-">memoryIO( mockData?, delay? )</h3>
<p>Endpoint for mock testing. Takes optional array with mock data, and optional <code>delay</code> parameter which is the simulated I/O delay in milliseconds.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { memoryIO } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r/endpoints/memory'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = memoryIO();
    ...
}
</code></pre>
<h3 id="localstorageio-key-">localStorageIO( key )</h3>
<p>Endpoint for localStorage. Takes <code>key</code> parameter which must be unique for the persistent record&#39;s collection.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { localStorageIO } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r/endpoints/localStorage'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = localStorageIO( <span class="hljs-string">'/users'</span> );
    ...
}
</code></pre>
<h3 id="attributesio-">attributesIO()</h3>
<p>Endpoint for I/O composition. Redirects record&#39;s <code>fetch()</code> request to its attributes and returns the combined abortable promise. Does not enable any other I/O methods and can be used with <code>record.fetch()</code> only.</p>
<p>It&#39;s common pattern to use attributesIO endpoint in conjunction with Store to fetch all the data required by SPA page.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { localStorageIO } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r/endpoints/attributes'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageStore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Store</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = attributesIO();
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">users</span> : User.Collection,
        <span class="hljs-attr">roles</span> : UserRole.Collection,
    }
}
...
const store = <span class="hljs-keyword">new</span> PageStore();
store.fetch().then( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> renderUI() );
</code></pre>
<h3 id="proxyio-recordctor-">proxyIO( RecordCtor )</h3>
<p>Create IO endpoint from the Record class. This endpoint is designed for use on the server side with a data layer managed by Type-R.</p>
<p>Assuming that you have Type-R records with endpoints working with the database, you can create an endpoint which will use
an existing Record subclass as a transport. This endpoint can be connected to the RESTful endpoint API on the server side which will serve JSON to the restfulIO endpoint on the client.</p>
<p>An advantage of this approach is that JSON schema will be transparently validated on the server side by the Type-R.</p>
<pre><code class="highlight javascript">    <span class="hljs-keyword">import</span> { proxyIO } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r/endpoint/proxy'</span>

    ...

    const usersIO = proxyIO( User );
</code></pre>
<h2 id="ioendpoint-interface">IOEndpoint Interface</h2>
<p>An IO endpoint is an &quot;plug-in&quot; abstraction representing the persistent collection of JSON objects, which is required to enable records and collections I/O API. There are several pre-defined endpoints included in Type-R package which can be used for HTTP REST I/O, mock testing, working with localStorage, and IO composition.</p>
<p>You will need to define custom endpoint if you would like to implement or customize serialization transport for Type-R objects. Use built-in endpoints as an example and the starting boilerplate.</p>
<p>All IOEndpoint methods might return standard Promises or abortable promises (created with <code>createIOPromise()</code>). An IOEndpoint instance is shared by all of the class instances it&#39;s attached to and therefore it&#39;s normally <em>must be stateless</em>.</p>
<h3 id="endpoint-read-id-options-record-">endpoint.read( id, options, record )</h3>
<p>Reads an object with a given id. Used by <code>record.fetch()</code> method. Must return JSON wrapped in abortable promise.</p>
<h3 id="endpoint-update-id-json-options-record-">endpoint.update( id, json, options, record )</h3>
<p>Updates or creates an object with a given id. Used by <code>record.save()</code> method when record <em>already has</em> an id. Must return abortable promise.</p>
<h3 id="endpoint-create-json-options-record-">endpoint.create( json, options, record )</h3>
<p>Creates an object. Used by <code>record.save()</code> method when record <em>does not</em> have an id. Must return abortable promise.</p>
<h3 id="endpoint-destroy-id-options-record-">endpoint.destroy( id, options, record )</h3>
<p>Destroys the object with the given id. Used by <code>record.destroy()</code> method. Must return abortable promise.</p>
<h3 id="endpoint-list-options-collection-">endpoint.list( options, collection )</h3>
<p>Fetch an array of objects. Used by <code>collection.fetch()</code> method. Must returns abortable promise.</p>
<h3 id="endpoint-subscribe-callbacks-collection-">endpoint.subscribe( <code>callbacks</code>, collection )</h3>
<p>Optional method to enable the live updates subscription. Used by <code>collection.liveUpdates( true )</code> method. Must returns abortable promise.</p>
<p>Method <code>callbacks</code> argument is an object of the following shape:</p>
<pre><code class="highlight javascript">{
    <span class="hljs-comment">// Endpoint must call it when an object is created or updated.</span>
    updated( json ){}

    <span class="hljs-comment">// Endpoint must call it when an object is removed.</span>
    removed( json ){}
}
</code></pre>
<h3 id="endpoint-unsubscribe-callbacks-collection-">endpoint.unsubscribe( <code>callbacks</code>, collection )</h3>
<p>Unsubscribe from the live updates. Used by <code>collection.liveUpdates( false )</code> method. Takes the same <code>callbacks</code> object as <code>subscribe()</code>.</p>
<h3 id="createiopromise-init-">createIOPromise( init )</h3>
<p>Service function to create an abortable version of ES6 promise (with <code>promise.abort()</code> which meant to stop pending I/O and reject the promise).</p>
<p><code>init</code> function takes the third <code>onAbort</code> argument to register an optional abort handler. If no handler is registered, the default implementation of <code>promise.abort()</code> will just reject the promise.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { createIOPromise } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

<span class="hljs-keyword">const</span> abortablePromise = createIOPromise( <span class="hljs-function">(<span class="hljs-params"> resolve, reject, onAbort </span>) =&gt;</span>{
    ...
    onAbort( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        reject( <span class="hljs-string">'I/O Aborted'</span> );
    });
});
</code></pre>
<h2 id="serialization">Serialization</h2>
<p>Record and Collection has a portion of common API related to the I/O and serialization.</p>
<h3 id="obj-tojson-">obj.toJSON()</h3>
<p>Serialize record or collection to JSON. Used internally by I/O methods. Can be overridden to customize serialization.</p>
<p>Produces the JSON for the given record or collection and its aggregated members. Aggregation tree is serialized as nested JSON. Record corresponds to an object in JSON, while the collection is represented as an array of objects.</p>
<p>If you override <code>toJSON()</code>, it usually means that you must override <code>parse()</code> as well, and vice versa.</p>
<aside class="notice">
Serialization can be controlled on per-attribute level with <b>Type.has.toJSON()</b> declaration.
</aside>

<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">body</span> : <span class="hljs-string">''</span>
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlogPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">title</span> : <span class="hljs-string">''</span>,
        <span class="hljs-attr">body</span> : <span class="hljs-string">''</span>,
        <span class="hljs-attr">comments</span> : Comment.Collection
    }
}

<span class="hljs-keyword">const</span> post = <span class="hljs-keyword">new</span> BlogPost({
    <span class="hljs-attr">title</span>: <span class="hljs-string">"Type-R is cool!"</span>,
    <span class="hljs-attr">comments</span> : [ { <span class="hljs-attr">body</span> : <span class="hljs-string">"Agree"</span> }]
});

<span class="hljs-keyword">const</span> rawJSON = post.toJSON()
<span class="hljs-comment">// { title : "Type-R is cool!", body : "", comments : [{ body : "Agree" }] }</span>
</code></pre>
<h3 id="option-parse-true-"><code>option</code> { parse : true }</h3>
<p><code>obj.set()</code> and constructor&#39;s option to force parsing of the raw JSON. Is used internally by I/O methods to parse the data received from the server.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Another way of doing the bestSeller.clone()</span>
<span class="hljs-comment">// Amazingly, this is guaranteed to work by default.</span>
<span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> Book();
book.set( bestSeller.toJSON(), { <span class="hljs-attr">parse</span> : <span class="hljs-literal">true</span> } );
</code></pre>
<h3 id="callback-obj-parse-json-"><code>callback</code> obj.parse( json )</h3>
<p>Optional hook called to transform the JSON when it&#39;s passes to the record or collection with <code>set( json, { parse : true })</code> call. Used internally by I/O methods.</p>
<p>If you override <code>toJSON()</code>, it usually means that you must override <code>parse()</code> as well, and vice versa.</p>
<aside class="notice">
Parsing can be controlled on per-attribute level with <b>Type.has.parse()</b> declaration.
</aside>

<h3 id="attrdef-type-has-tojson-false-"><code>attrDef</code> : Type.has.toJSON( false )</h3>
<p>Do <em>not</em> serialize the specific attribute.</p>
<h3 id="attrdef-type-has-tojson-value-name-json-"><code>attrDef</code> : Type.has.toJSON( ( value, name ) =&gt; json )</h3>
<p>Override the default serialization for the specific record&#39;s attribute.</p>
<p>Attribute is not serialized when the function return <code>undefined</code>.</p>
<h3 id="attrdef-type-has-parse-json-name-value-"><code>attrDef</code> : Type.has.parse( ( json, name ) =&gt; value )</h3>
<p>Transform the data before it will be assigned to the record&#39;s attribute.</p>
<p>Invoked when the <code>{ parse : true }</code> option is set.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Define custom boolean attribute type which is serialized as 0 or 1.</span>
<span class="hljs-keyword">const</span> MyWeirdBool = <span class="hljs-built_in">Boolean</span>.has
                      .parse( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x === <span class="hljs-number">1</span> )
                      .toJSON( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span> );
</code></pre>
<h3 id="static-create-attrs-options-"><code>static</code> create( attrs, options )</h3>
<p>Static factory function used internally by Type-R to create instances of the record.</p>
<p>May be redefined in the abstract Record base class to make it serializable type.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">type</span> : <span class="hljs-built_in">String</span>
    }

    <span class="hljs-keyword">static</span> create( attrs, options ){
        <span class="hljs-keyword">switch</span>( attrs.type ){
            <span class="hljs-keyword">case</span> <span class="hljs-string">"typeA"</span> : <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TypeA( attrs, options );
            <span class="hljs-keyword">case</span> <span class="hljs-string">"typeB"</span> : <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TypeB( attrs, options );
        }
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Widget</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">type</span> : <span class="hljs-string">"typeA"</span>,
        ...
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Widget</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">type</span> : <span class="hljs-string">"typeB"</span>,
        ...
    }
}
</code></pre>
<h2 id="normalized-data">Normalized data</h2>
<p>Type-R has first-class support for working with normalized data represented as a set of collections with cross-references by record id. References are represented as record ids in JSON, and being transparently resolved to record instances on the first access.</p>
<p><code>Store</code> class is the special record class which serves as a placeholder for the set of interlinked collections of normalized records. Id-references are defined as record attributes of the special type representing the serializable reference to the records from the specified master collection.</p>
<h3 id="attrdef-record-from-sourcecollection-"><code>attrDef</code> : Record.from( <code>sourceCollection</code> )</h3>
<p>Serializable reference to the record from the particular collection.
Initialized as <code>null</code> and serialized as <code>record.id</code>. Is not recursively cloned, validated, or disposed. Used to model one-to-many relationships.</p>
<p>Changes in shared record are not detected.</p>
<p><code>sourceCollection</code> may be:</p>
<ul>
<li>the JS variable pointing to the collection singleton;</li>
<li>the function returning the collection;</li>
<li>the string with the dot-separated <em>relative object path</em> to the collection. It is resolved dynamically relative to the record&#39;s <code>this</code>. Following shortcuts may be used in path:<ul>
<li><code>owner.path</code> (or <code>^path</code>) works as <code>() =&gt; this.getOwner().path</code>.</li>
<li><code>store.path</code> (or <code>~path</code>) works as <code>() =&gt; this.getStore().path</code>.</li>
</ul>
</li>
</ul>
<pre><code class="highlight javascript">    @define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
        items : Item.Collection,
        <span class="hljs-attr">selected</span> : Record.from( <span class="hljs-string">'items'</span> ) <span class="hljs-comment">// Will resolve to `this.items`</span>
    }
</code></pre>
<aside class="info">It's recommended to use ~paths and stores instead of ^paths.</aside>

<h3 id="attrdef-collection-subsetof-sourcecollection-"><code>attrDef</code> : Collection.subsetOf( <code>sourceCollection</code> )</h3>
<p>Serializable non-aggregating collection which is the subset of the particular collection. Serialized as an array of record ids. Used to model many-to-many relationships.</p>
<p>The collection itself is recursively created and cloned. However, its records are not aggregated by the collection thus they are not recursively cloned, validated, or disposed.</p>
<p><code>sourceCollection</code> is the same reference as used by <code>Record.from()</code>.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>,
        ...
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">roles</span> : Role.Collection.subsetOf( <span class="hljs-string">'~roles'</span> )
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersDirectory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Store</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">roles</span> : Role.Collection,
        <span class="hljs-attr">users</span> : User.Collection <span class="hljs-comment">// `~roles` references will be resolved against this.roles</span>
    }
}
</code></pre>
<h3 id="collection-createsubset-records-options-">collection.createSubset( records?, options? )</h3>
<p>Create an instance of <code>Collection.subsetOf( collection )</code> type (non-aggregating serializable collection) which is the subset of the given collection. Takes the same arguments as the collection&#39;s constructor.</p>
<aside class="notice">
Records in the collection must have an `id` attribute populated to work properly with subsets.
</aside>

<h3 id="class-store"><code>class</code> Store</h3>
<p><code>Store</code> is the special kind of record which serves as a root for id references.</p>
<p>For all records inside of the store&#39;s aggregation tree <code>~attrName</code> will resolve to the attribute of the store class found with <code>record.getStore()</code> method. If there are no such an attribute in the store, the next available store upper in aggregation tree will be used (as regular records stores can be nested), or the default store if there are no one.</p>
<aside class="notice">Stores in Type-R is _very different_ to stores in other framework. Pay attention.</aside>

<p>Store is the subclass of the Record. It&#39;s defined extending the <code>Store</code> abstract base class. It behaves as a regular record in most aspects.</p>
<h3 id="store-_defaultstore">store._defaultStore</h3>
<p>Reference to the master store used for lookups if the current store doesn&#39;t have the required attribute and there are no other store found upper in the ownership chain.</p>
<p>Defaults to the <code>Store.global</code>. May be explicitly defined to create custom store lookup chains across the ownership hierarchy.</p>
<h3 id="static-store-global"><code>static</code> Store.global</h3>
<p>The default singleton store class. Is always the last store to lookup when resolving ~reference.</p>
<p>Use the default store for the <em>globally shared data only</em>. Each application page must have its local store.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Store</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">users</span> : User.Collection,
        <span class="hljs-attr">roles</span> : Role.Collection
    }
}

Store.global = <span class="hljs-keyword">new</span> MyStore();

<span class="hljs-comment">// Now the reference '~users` will point to users collection from the MyStore.</span>
</code></pre>
<h3 id="recordorcollection-getstore-">recordOrCollection.getStore()</h3>
<p>Return the closest store. Used internally to resolve symbolic <code>~reference</code> relative to the store.</p>
<p>Method looks for the <code>Store</code> subclass traversing the ownership chain of current aggregation tree upwards. If there are no store found this way, default Store from <code>Store.global</code> is returned.</p>
<h3 id="recordorcollection-clone-pinstore-true-">recordOrCollection.clone({ pinStore : true })</h3>
<p>Make the cloned object to preserve the reference to its original store.</p>
<p>Cloned objects don&#39;t have an owner by default, thus they loose the reference to their store as no ownership chain can be traversed. <code>pinStore</code> option should be used in such a cases.</p>
<h1 id="reactjs-bindings">ReactJS bindings</h1>
<p><a href="https://volicon.github.io/React-MVx/">React-MVx</a> is an MVVM application frameworks which uses Type-R to manage a multi-layer application state.</p>
<ul>
<li>React-MVx adds <a href="https://volicon.github.io/React-MVx/#link">two-way data binding</a> capabilities to both Record and Collection. Data-binding is based on the <a href="https://medium.com/@gaperton/managing-state-and-forms-with-react-part-1-12eacb647112">&quot;value link&quot; pattern</a> and implemented with Link class from <a href="https://github.com/Volicon/NestedLink">NestedLink</a> library taking the value and validation error directly from the Record.</li>
<li><a href="https://volicon.github.io/Type-R/#record">Record</a> class is used to manage <a href="https://volicon.github.io/React-MVx/#state">component&#39;s state</a>.</li>
<li>The subset of the <a href="https://volicon.github.io/Type-R/#definition">Record attributes type annotation</a> is used to define component <a href="https://volicon.github.io/React-MVx/#props">props</a> and <a href="https://volicon.github.io/React-MVx/#context">context</a>.</li>
<li><a href="https://volicon.github.io/Type-R/#store">Store</a> class is used to represent <a href="https://volicon.github.io/React-MVx/#store">component&#39;s store</a> (also called &quot;local store&quot;), which is typically used in the root component of SPA page associated with a route. The state of the children components uses upper component&#39;s stores to resolve id-references.</li>
<li>Type-R <a href="https://volicon.github.io/Type-R/#-static-store-global">global store</a> may be used as a store for the data shared by application pages. This store is used to resolve id-references in case if local stores lookup failed.</li>
</ul>
<aside class="warning">
The meaning of the Store in Type-R and React-Mvx is very different to that in other frameworks. The sole reason you need the store is to have collections of records which are being used to resolve id-references. If you don't have <a href="https://volicon.github.io/Type-R/#normalized-data">id-references</a> in JSON, you don't need stores. Use state instead.
</aside><h1 id="class-definitions-and-mixins">Class definitions and mixins</h1>
<h2 id="class-definitions">Class Definitions</h2>
<p>Type-R mechanic is based on class transformations at the moment of module load. These transformations are controlled by <em>definitions</em> in static class members.</p>
<h3 id="decorator-definitions-propname-rule-"><code>decorator</code> @definitions({ propName : <code>rule</code>, ... })</h3>
<p>Treat specified static class members as <em>definitions</em>. When <code>@define</code> decorator is being called, definitions are extracted from static class members and mixins and passed as an argument to the <code>Class.onDefine( definition )</code>.</p>
<p>Class definitions are intended to use in the abstract base classes and they are inherited by subclasses. You don&#39;t need to add any new definitions to existing Type-R classes unless you want to extend the library, which you&#39;re welcome to do.</p>
<h3 id="rule-mixinrules-value"><code>rule</code> mixinRules.value</h3>
<p>Merge rule used to mark class definitions. The same rule is also applied to all mixin members if other rule is not specified.</p>
<pre><code class="highlight javascript">@define
@definitions({
    <span class="hljs-attr">urlRoot</span> : mixinRules.value
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> </span>{
    <span class="hljs-keyword">static</span> urlRoot = <span class="hljs-string">'/api'</span>;

    <span class="hljs-keyword">static</span> onDefine( definition ){
        <span class="hljs-keyword">this</span>.prototype.urlRoot = definition.urlRoot;
    }
}
</code></pre>
<h3 id="rule-mixinrules-protovalue"><code>rule</code> mixinRules.protoValue</h3>
<p>Same as <code>mixinRules.value</code>, but the value is being assigned to the class prototype.</p>
<pre><code class="highlight javascript">@define
@definitions({
    <span class="hljs-attr">urlRoot</span> : mixinRules.protoValue
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> </span>{
    <span class="hljs-keyword">static</span> urlRoot = <span class="hljs-string">'/api'</span>;
}

assert( X.prototype.urlRoot === <span class="hljs-string">'/api'</span> );
</code></pre>
<h3 id="rule-mixinrules-merge"><code>rule</code> mixinRules.merge</h3>
<p>Assume the property to be the key-value hash. Properties with the same name from mixins are merged.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> M = {
    <span class="hljs-attr">attributes</span> : {
        <span class="hljs-attr">b</span> : <span class="hljs-number">1</span>
    }
};

@define
@mixins( M )
@definitions({
    <span class="hljs-attr">attributes</span> : mixinRules.merge
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">a</span> : <span class="hljs-number">1</span>
    };

    onDefine( definitions ){
        <span class="hljs-keyword">const</span> { attributes } = definitions;
        assert( attributes.a === attributes.b === <span class="hljs-number">1</span> );
    }
}
</code></pre>
<h3 id="decorator-define"><code>decorator</code> @define</h3>
<p>Extract class definitions, call class definition hooks, and apply mixin merge rules to inherited class members.</p>
<ol>
<li>Call static <code>onExtend( BaseClass )</code> hook.</li>
<li>Extract definitions from static class members and all the mixins applied, and pass them to <code>onDefine( definitions, BaseClass )</code> hook.</li>
<li>Apply <em>merge rules</em> for overriden class methods.</li>
</ol>
<p>All Type-R class definitions must be precedeed with the <code>@define</code> (or <code>@predefine</code>) decorator.</p>
<pre><code class="highlight javascript">@define
@definitions({
    <span class="hljs-attr">attributes</span> : mixinRules.merge
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> onDefine( definitions, BaseClass ){
        definitions.attributes &amp;&amp; <span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">JSON</span>.stringify( definitions.attributes ) );
    }
}

<span class="hljs-comment">// Will print "{ "a" : 1 }"</span>
@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">a</span> : <span class="hljs-number">1</span>
    }
}

<span class="hljs-comment">// Will print "{ "b" : 1 }"</span>
@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">b</span> : <span class="hljs-number">1</span>
    }
}
</code></pre>
<h3 id="decorator-define-mixin-"><code>decorator</code> @define( mixin )</h3>
<p>When called with an argument, <code>@define</code> decorator applies the given mixin as if it would be the first mixin applied.
In other aspects, it behaves the same as the <code>@default</code> decorator without argument.</p>
<h3 id="static-class-onextend-baseclass-"><code>static</code> Class.onExtend( BaseClass )</h3>
<p>Called from the <code>@predefine</code> or as the first action of the <code>@define</code>. Takes base class constructor as an argument.</p>
<h3 id="static-class-ondefine-definition-baseclass-"><code>static</code> Class.onDefine( definition, BaseClass )</h3>
<p>Called from the <code>@define</code> or <code>Class.define()</code> method. Takes class definition (see the <code>@definitions</code> decorator) as the first argument.</p>
<h3 id="decorator-predefine"><code>decorator</code> @predefine</h3>
<p>The sequence of <code>@predefine</code> with the following <code>Class.define()</code> call is equivalent to <code>@define</code> decorator. It should be used in the case if the class definition must reference itself, or multiple definitions contain circular dependency. </p>
<p>It calls static <code>onExtend( BaseClass )</code> function if it&#39;s defined. It assumes that the <code>Class.define( definitions )</code> method will be called later, and attaches <code>Class.define</code> method to the class if it was not defined.</p>
<h3 id="static-class-define-definitions-"><code>static</code> Class.define( definitions? )</h3>
<p>Finalized the class definition started with <code>@predefine</code> decorator. Has the same effect as the <code>@define</code> decorator excepts it assumes that <code>Class.onExtend()</code> static function was called already.</p>
<h2 id="mixins">Mixins</h2>
<h3 id="decorator-mixins-mixina-mixinb-class-x-"><code>decorator</code> @mixins( mixinA, mixinB, ... ) class X ...</h3>
<p>Merge specified mixins to the class definition. Both plain JS object and class constructor may be used as mixin. In the case of the class constructor, missing static members will copied over as well.</p>
<pre><code class="highlight javascript">    <span class="hljs-keyword">import</span> { mixins, Events } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>
    ...

    @define
    @mixins( Events, plainObject, MyClass, ... )
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> </span>{
        ...
    }
</code></pre>
<h3 id="static-class-mixins"><code>static</code> Class.mixins</h3>
<p>Class member holding the state of the class mixins.</p>
<aside class="warning">
This is an experimental API which may change in future.
</aside>

<h2 id="merge-rules">Merge rules</h2>
<h3 id="decorator-mixinrules-propname-rule-"><code>decorator</code> @mixinRules({ propName : <code>rule</code>, ... })</h3>
<p>The <code>rule</code> is the reducer function which is applied when there are several values for the particular class members are defined in different mixins or the class, or if the class member is overriden by the subclass.</p>
<aside class="warning">
This is an experimental feature to support React-style mixins. Should be used with an extreme care.
</aside>

<h3 id="rule-mixinrules-classfirst"><code>rule</code> mixinRules.classFirst</h3>
<p>Assume the property to be the function. Call functions from mixins in sequence: <code>f1.apply( this, arguments ); f2.apply( this, arguments );...</code></p>
<h3 id="rule-mixinrules-classlast"><code>rule</code> mixinRules.classLast</h3>
<p>Same as sequence, but functions are called in the reverse sequence.</p>
<pre><code class="highlight javascript">@define
@mixinRules({
    <span class="hljs-attr">componentWillMount</span> : mixinRules.classLast
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> </span>{
    componentWillMount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">1</span> );
    }
}

<span class="hljs-keyword">const</span> M = {
    componentWillMount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">2</span> );
    }
}

@define
@mixins( M )
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
    componentWillMount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">3</span> );
    }
}

<span class="hljs-keyword">const</span> x = <span class="hljs-keyword">new</span> X();
x.componentWillMount();
<span class="hljs-comment">// Will print 1, 2, 3</span>

</code></pre>
<h3 id="rule-mixinrules-pipe"><code>rule</code> mixinRules.pipe</h3>
<p>Assume the property to be the function with a signature <code>( x : T ) =&gt; T</code>. Join functions from mixins in a pipe: <code>f1( f2( f3( x ) ) )</code>.</p>
<h3 id="rule-mixinrules-defaults"><code>rule</code> mixinRules.defaults</h3>
<p>Assume the property to be the function returning object. Merge objects returned by functions from mixins, executing them in sequence.</p>
<h3 id="rule-mixinrules-every"><code>rule</code> mixinRules.every</h3>
<p>Assume property to be the function returning boolean. Return <code>true</code> if all functions from mixins return truthy values.</p>
<h3 id="rule-mixinrules-some"><code>rule</code> mixinRules.some</h3>
<p>Same as <code>every</code>, but return true when at least one function from mixins returns true.</p>
<h1 id="release-notes">Release Notes</h1>
<h2 id="2-1-0">2.1.0</h2>
<p>This release adds long-awaited HTTP REST endpoint.</p>
<ul>
<li>IO endpoints moved outside of the man sources tree. Creation of the custom endpoints is easier than ever.</li>
<li>Added HTTP REST endpoint <code>restfulIO</code> with relative urls support (<a href="https://volicon.github.io/Type-R/#endpoint-restfulio-url-options-)">https://volicon.github.io/Type-R/#endpoint-restfulio-url-options-)</a>.</li>
<li>Added proxyIO endpoint for creating endpoints from records on the server side (<a href="https://volicon.github.io/Type-R/#endpoint-proxyio-recordctor-)">https://volicon.github.io/Type-R/#endpoint-proxyio-recordctor-)</a>.</li>
</ul>
<h2 id="2-0-0">2.0.0</h2>
<p>This release brings new features which fixes problems with component&#39;s inheritance in React bindings and implements long-awaited generic IO implementation based on ES6 promises.</p>
<p>There shouldn&#39;t be breaking changes <em>unless</em> you&#39;re using custom logger or React bindings (formerly known as React-MVx, with a name changed to React-R in new release).</p>
<h3 id="generic-io-support">Generic IO support</h3>
<p>New <a href="">IOEndpoint</a> concept is introduced, making it easy to create IO abstractions. To enable <code>Record</code> and <code>Collection</code> IO API, you need to assign IO endpoint in the class definition.</p>
<p>Endpoint is the class defining CRUD and list operations on JSON data, as well as the methods to subscribe for the data changes. There are two endpoints included with 2.0 release, <code>memoryIO</code> which is suitable for mock testing and <code>localStorageIO</code> which could be used in demos and prototypes. They can be used as a references as starting points to define your own IO endpoints.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = memoryIO();
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>,
        ...
    }
}
</code></pre>
<p>There are three Record IO methods (<code>save()</code>, <code>fetch()</code>, and <code>destroy()</code>) and two collection IO method (<code>fetch()</code> and <code>liveUpdates()</code>) ). All IO methods returns ES6 promises, so you either must have the runtime supporting ES6 or use the ES6 promise polyfill. The promises are modified to be <em>abortable</em> (all of them have <code>abort()</code> method).</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User({ <span class="hljs-attr">name</span> : <span class="hljs-string">'John'</span> });
user.save().then( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">`new user is added <span class="hljs-subst">${ user.id }</span>`</span> )
});
</code></pre>
<p>There&#39;s the special <code>attributesIO()</code> endpoint to fetch all of attributes independently and return the combined promise. This is the recommended way of fetching the data required by SPA page.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageStore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Store</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = attributesIO();
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">users</span> : User.Collection,
        <span class="hljs-attr">roles</span> : UserRole.Collection,
        ...
    }
}

<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> PageStore();
store.fetch().then( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>{
    <span class="hljs-comment">// render your page</span>
});
</code></pre>
<p>It&#39;s possible to define or override the defined endpoint for the nested model or collection using <code>has.endpoint</code> type-R attribute annotation.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageStore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Store</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = attributesIO();
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">users</span> : User.Collection.has.endpoint( restful( <span class="hljs-string">'/api/users'</span> ) ),
        <span class="hljs-attr">roles</span> : UserRole.Collection.has.endpoint( restful( <span class="hljs-string">'/api/userroles'</span> ) ),
        ...
    }
}
</code></pre>
<aside class="notice">
Please note, that `restful` endpoint is not included with 2.0 release but is planned for the future 2.x releases.
</aside>

<h3 id="new-mixins-engine">New mixins engine</h3>
<p>Type-R metaprogramming system built on powerful mixins composition with configurable member merge rules. In 2.0 release, mixins engine was rewritten to properly apply merge rules on inheritance. This feature is heavily used in Type-R React&#39;s bindings and is crucial to prevent errors when extending the <code>React.Component</code> subclasses.</p>
<p>An example illustrating the principle:</p>
<pre><code class="highlight javascript">@define
<span class="hljs-comment">// Define the class with </span>
@mixinRules({
    <span class="hljs-attr">componentWillMount</span> : mixinRules.classLast,
    <span class="hljs-attr">componentWillUnmount</span> : mixinRules.classFirst
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> </span>{
    componentWillMount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">1</span> );
    }

    componentWillUnmount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">3</span> );
    }
}

@define
@mixins({
    componentWillMount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">2</span> );
    },

    componentWillUnmount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">2</span> );
    }
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBaseComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
    componentWillMount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">3</span> );
    }

    componentWillUnmount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">1</span> );
    }
}
</code></pre>
<p>In this example, all of the methods defined in the mixin, base class, and subclass will be called in the order specified in the <code>console.log</code>.</p>
<h3 id="other-changes">Other changes</h3>
<ul>
<li>Update pipeline was rewritten to improve record&#39;s initialization speed (collection&#39;s fetch speed is improved by 30%).</li>
<li>Fixed bug which case dynamic type checks to be disabled in records constructors.</li>
<li>New implementation of the <code>Collection.subsetOf</code> which both fixes some edge case bugs and is more efficient.</li>
<li>New logger handling NODE_ENV variable setting.</li>
</ul>
        </div>
    </div>
  </body>
</html>
